"""
서울경제신문 AI 요약 시스템 - REST API 엔드포인트
공통 로직은 core_processor.py로 분리하여 중복 제거
"""

import json
import boto3
import os
import logging
import traceback
from datetime import datetime
import sys
from pathlib import Path

# 공통 처리 모듈 import
sys.path.append(str(Path(__file__).parent))
sys.path.append(str(Path(__file__).parent.parent / 'utils'))

try:
    from core_processor import get_news_processor
    from common_utils import DecimalEncoder
except ImportError as e:
    logger.error(f"모듈 import 오류: {e}")

# 로깅 설정
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# 환경 변수
MODEL_ID = "anthropic.claude-3-sonnet-20240229-v1:0"

def lambda_handler(event, context):
    """메인 Lambda 핸들러 - REST API 방식"""
    try:
        logger.info(f"📝 REST API 요청 시작: {json.dumps(event, ensure_ascii=False)[:200]}")
        
        # 요청 파싱
        http_method = event.get("httpMethod", "POST")
        path = event.get("path", "")
        
        # 요청 본문 파싱
        body = {}
        if http_method == 'POST':
            try:
                body = json.loads(event.get('body', '{}'))
            except json.JSONDecodeError:
                return _create_error_response(400, "잘못된 JSON 형식입니다.")
        else:
            body = event.get('queryStringParameters') or {}
        
        user_input = body.get('userInput', '').strip()
        chat_history = body.get('chat_history', [])
        model_id = body.get('modelId', MODEL_ID)
        
        if not user_input:
            return _create_error_response(400, "사용자 입력이 필요합니다.")
        
        # 공통 처리 로직 사용
        news_processor = get_news_processor()
        
        # 스트리밍 vs 일반 응답 분기
        if "/stream" in path:
            return _handle_streaming_generation(news_processor, user_input, chat_history, model_id)
        else:
            return _handle_standard_generation(news_processor, user_input, chat_history, model_id)
            
    except Exception as e:
        logger.error(f"❌ Handler 오류: {str(e)}")
        logger.error(f"❌ Traceback: {traceback.format_exc()}")
        return _create_error_response(500, f"서버 내부 오류: {e}")

def _handle_standard_generation(news_processor, user_input, chat_history, model_id):
    """일반 생성 처리 - 공통 로직 활용"""
    try:
        logger.info(f"📝 일반 생성 시작: {user_input[:50]}...")
        
        # 공통 처리 엔진으로 전체 플로우 실행
        result = news_processor.process_complete_flow(user_input, chat_history, model_id)
        
        if not result['success']:
            return _create_error_response(500, f"생성 중 오류가 발생했습니다: {result['error']}")
        
        return {
            'statusCode': 200,
            'headers': _get_cors_headers(),
            'body': json.dumps({
                'success': True,
                'response': result['response'],
                'model': model_id,
                'timestamp': datetime.now().isoformat()
            }, ensure_ascii=False, cls=DecimalEncoder)
        }
        
    except Exception as e:
        logger.error(f"❌ 생성 오류: {str(e)}")
        return _create_error_response(500, f"생성 중 오류가 발생했습니다: {e}")

def _handle_streaming_generation(news_processor, user_input, chat_history, model_id):
    """스트리밍 생성 처리 - SSE 방식으로 REST에서도 스트리밍 지원"""
    try:
        logger.info(f"🌊 REST 스트리밍 생성 시작: {user_input[:50]}...")
        
        # 1단계: 날짜 정의 및 질문 보강
        enhanced_query = news_processor.enhance_query_with_date(user_input)
        streaming_body = f"data: {json.dumps({'status': 'processing', 'message': '질문을 분석했습니다.'}, ensure_ascii=False)}\n\n"
        
        # 2단계: AWS 내부 지식 검색
        streaming_body += f"data: {json.dumps({'status': 'searching', 'message': '관련 뉴스를 검색하고 있습니다.'}, ensure_ascii=False)}\n\n"
        knowledge_context = news_processor.search_knowledge_base(enhanced_query)
        
        # 3단계: 필요시 외부 검색
        if news_processor.should_use_external_search(knowledge_context, user_input):
            streaming_body += f"data: {json.dumps({'status': 'external_searching', 'message': '최신 정보를 추가로 검색하고 있습니다.'}, ensure_ascii=False)}\n\n"
            external_context = news_processor.search_external_knowledge(enhanced_query)
            knowledge_context += f"\n\n[외부 검색 결과]\n{external_context}"
        
        # 4단계: 최종 프롬프트 구성
        final_prompt = news_processor.build_final_prompt(user_input, chat_history, knowledge_context)
        
        # 5단계: 스트리밍 생성
        streaming_body += f"data: {json.dumps({'status': 'generating', 'message': '답변을 생성하고 있습니다.'}, ensure_ascii=False)}\n\n"
        
        # Bedrock 스트리밍 생성
        bedrock_runtime = boto3.client(
            service_name='bedrock-runtime',
            region_name=os.environ.get('AWS_REGION', 'ap-northeast-2')  # 서울리전으로 변경
        )
        
        request_body = {
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 4000,
            "temperature": 0.1,
            "messages": [{"role": "user", "content": final_prompt}]
        }
        
        # 스트리밍 응답 처리
        response = bedrock_runtime.invoke_model_with_response_stream(
            modelId=model_id,
            contentType='application/json',
            accept='application/json',
            body=json.dumps(request_body)
        )
        
        # SSE 형식으로 스트리밍 응답 구성
        for event in response['body']:
            chunk = json.loads(event['chunk']['bytes'])
            if chunk['type'] == 'content_block_delta':
                text = chunk['delta'].get('text', '')
                if text:
                    sse_chunk = f"data: {json.dumps({'text': text}, ensure_ascii=False)}\n\n"
                    streaming_body += sse_chunk
        
        # 완료 메시지
        streaming_body += f"data: {json.dumps({'status': 'completed', 'message': '답변 생성이 완료되었습니다.'}, ensure_ascii=False)}\n\n"
        streaming_body += "data: [DONE]\n\n"
        
        return {
            'statusCode': 200,
            'headers': {
                **_get_cors_headers(),
                'Content-Type': 'text/event-stream',
                'Cache-Control': 'no-cache',
                'Connection': 'keep-alive'
            },
            'body': streaming_body
        }
        
    except Exception as e:
        logger.error(f"❌ 스트리밍 오류: {str(e)}")
        return _create_error_response(500, f"스트리밍 중 오류가 발생했습니다: {e}")

def _create_error_response(status_code, message):
    """에러 응답 생성"""
    return {
        'statusCode': status_code,
        'headers': _get_cors_headers(),
        'body': json.dumps({
            'success': False,
            'error': message,
            'timestamp': datetime.now().isoformat()
        }, ensure_ascii=False)
    }

def _get_cors_headers():
    """CORS 헤더"""
    return {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
    } 