"""
서울경제신문 AI 요약 시스템 - WebSocket 실시간 스트리밍 
공통 로직은 core_processor.py로 분리하여 중복 제거
실시간 피드백과 상태 메시지를 통한 최적의 사용자 경험 제공
"""

import json
import boto3
import os
import logging
import traceback
from datetime import datetime
import sys
from pathlib import Path

# 공통 처리 모듈 import
sys.path.append(str(Path(__file__).parent.parent / 'generate'))
sys.path.append(str(Path(__file__).parent.parent / 'utils'))

try:
    from core_processor import get_news_processor
    from common_utils import DecimalEncoder
except ImportError as e:
    print(f"모듈 import 오류: {e}")

# 로깅 설정
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# AWS 클라이언트 초기화
bedrock_runtime = boto3.client(
    service_name='bedrock-runtime',
    region_name=os.environ.get('AWS_REGION', 'us-east-1')
)

apigateway = boto3.client('apigatewaymanagementapi',
    endpoint_url=f"https://{os.environ.get('API_GATEWAY_DOMAIN')}/{os.environ.get('STAGE', 'prod')}"
)

# 환경 변수
MODEL_ID = "anthropic.claude-3-sonnet-20240229-v1:0"

def lambda_handler(event, context):
    """WebSocket 메시지 처리"""
    try:
        connection_id = event['requestContext']['connectionId']
        
        if event['requestContext']['eventType'] == 'MESSAGE':
            body = json.loads(event.get('body', '{}'))
            action = body.get('action')
            
            if action == 'stream':
                return handle_stream_request(connection_id, body)
            else:
                return send_error(connection_id, "지원하지 않는 액션입니다.")
        
        return {'statusCode': 200}
        
    except Exception as e:
        logger.error(f"❌ WebSocket 핸들러 오류: {str(e)}")
        logger.error(f"❌ Traceback: {traceback.format_exc()}")
        return {'statusCode': 500}

def handle_stream_request(connection_id, data):
    """실시간 스트리밍 요청 처리 - 공통 로직 활용"""
    try:
        # 요청 파라미터 추출
        user_id = data.get('userSub') or data.get('projectId') or "default"
        user_input = data.get('userInput', '').strip()
        chat_history = data.get('chat_history', [])
        model_id = data.get('modelId', MODEL_ID)
        
        logger.info(f"🌊 WebSocket 실시간 스트림: user_id={user_id}, input={user_input[:50]}...")
        
        if not user_input:
            return send_error(connection_id, "사용자 입력이 필요합니다.")
        
        # 공통 처리 엔진 초기화
        news_processor = get_news_processor()
        
        # 실시간 스트리밍 플로우 실행
        return execute_realtime_streaming_flow(connection_id, news_processor, user_input, chat_history, model_id)
        
    except Exception as e:
        logger.error(f"❌ 스트림 요청 처리 오류: {e}")
        return send_error(connection_id, f"처리 중 오류가 발생했습니다: {e}")

def execute_realtime_streaming_flow(connection_id, news_processor, user_input, chat_history, model_id):
    """실시간 스트리밍 플로우 실행 - 상태 메시지와 함께"""
    try:
        # 🚀 상태 1: 시작
        send_status_message(connection_id, "processing", "질문을 분석하고 있습니다...")
        
        # 📅 1단계: 날짜 정의 및 질문 보강
        enhanced_query = news_processor.enhance_query_with_date(user_input)
        logger.info(f"📅 날짜 보강된 질문: {enhanced_query}")
        
        # 🔍 상태 2: 검색 시작
        send_status_message(connection_id, "searching", "관련 뉴스를 검색하고 있습니다...")
        
        # 📰 2단계: AWS 내부 지식 검색 (최신순)
        knowledge_context = news_processor.search_knowledge_base(enhanced_query)
        
        # 🌍 3단계: 필요시 Perplexity API로 보강
        if news_processor.should_use_external_search(knowledge_context, user_input):
            send_status_message(connection_id, "external_searching", "최신 정보를 추가로 검색하고 있습니다...")
            
            external_context = news_processor.search_external_knowledge(enhanced_query)
            knowledge_context += f"\n\n[외부 검색 결과]\n{external_context}"
        
        # 💭 상태 3: 답변 생성 시작
        send_status_message(connection_id, "generating", "답변을 생성하고 있습니다...")
        
        # 📝 4단계: 최종 프롬프트 구성
        final_prompt = news_processor.build_final_prompt(user_input, chat_history, knowledge_context)
        
        # 🎨 5단계: 실시간 스트리밍 생성
        stream_bedrock_response_realtime(connection_id, final_prompt, model_id)
        
        # ✅ 완료 메시지 전송
        send_status_message(connection_id, "completed", "답변 생성이 완료되었습니다.")
        
        return {'statusCode': 200}
        
    except Exception as e:
        logger.error(f"❌ 실시간 스트리밍 플로우 오류: {e}")
        return send_error(connection_id, f"스트리밍 중 오류가 발생했습니다: {e}")

def stream_bedrock_response_realtime(connection_id, prompt, model_id):
    """실시간 Bedrock 스트리밍 응답 - WebSocket으로 즉시 전송"""
    try:
        # Claude 3 Sonnet용 스트리밍 요청 구성
        request_body = {
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 4000,
            "temperature": 0.1,
            "messages": [
                {
                    "role": "user",
                    "content": prompt
                }
            ]
        }
        
        # 스트리밍 응답 처리
        response = bedrock_runtime.invoke_model_with_response_stream(
            modelId=model_id,
            contentType='application/json',
            accept='application/json',
            body=json.dumps(request_body)
        )
        
        # 🔥 실시간으로 클라이언트에 스트리밍 전송
        full_response = ""
        for event in response['body']:
            chunk = json.loads(event['chunk']['bytes'])
            if chunk['type'] == 'content_block_delta':
                text = chunk['delta'].get('text', '')
                if text:
                    full_response += text
                    # ⚡ 즉시 실시간 청크 전송
                    send_stream_chunk(connection_id, text, is_partial=True)
        
        # 📄 완료된 전체 응답 전송
        send_stream_chunk(connection_id, full_response, is_partial=False, is_complete=True)
        
        logger.info(f"✅ 실시간 스트리밍 생성 완료: {len(full_response)}자")
        
    except Exception as e:
        logger.error(f"❌ 실시간 스트리밍 생성 오류: {e}")
        send_error(connection_id, f"답변 생성 중 오류가 발생했습니다: {e}")

def send_status_message(connection_id, status, message):
    """상태 메시지 전송 - 사용자에게 진행 상황 피드백"""
    try:
        status_message = {
            "type": "status",
            "status": status,
            "message": message,
            "timestamp": datetime.now().isoformat()
        }
        send_message(connection_id, status_message)
        logger.info(f"📤 상태 메시지 전송: {status} - {message}")
    except Exception as e:
        logger.error(f"❌ 상태 메시지 전송 오류: {e}")

def send_stream_chunk(connection_id, content, is_partial=True, is_complete=False):
    """스트리밍 청크 전송 - 실시간 텍스트 전송"""
    try:
        chunk_message = {
            "type": "stream",
            "content": content,
            "isPartial": is_partial,
            "isComplete": is_complete,
            "timestamp": datetime.now().isoformat()
        }
        send_message(connection_id, chunk_message)
    except Exception as e:
        logger.error(f"❌ 스트림 청크 전송 오류: {e}")

def send_message(connection_id, message):
    """WebSocket 메시지 전송"""
    try:
        apigateway.post_to_connection(
            ConnectionId=connection_id,
            Data=json.dumps(message, ensure_ascii=False)
        )
    except Exception as e:
        logger.error(f"❌ 메시지 전송 오류: {e}")

def send_error(connection_id, error_message):
    """에러 메시지 전송"""
    try:
        error_msg = {
            "type": "error",
            "error": error_message,
            "timestamp": datetime.now().isoformat()
        }
        send_message(connection_id, error_msg)
        return {'statusCode': 200}
    except Exception as e:
        logger.error(f"❌ 에러 전송 실패: {e}")
        return {'statusCode': 500}