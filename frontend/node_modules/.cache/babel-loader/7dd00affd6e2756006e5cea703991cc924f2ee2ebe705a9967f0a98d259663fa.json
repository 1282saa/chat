{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from \"react\";\nimport { toast } from \"react-hot-toast\";\nimport { copyToClipboard } from \"../utils/clipboard\";\nimport { useOrchestration } from \"./useOrchestration\";\nimport { useWebSocket } from \"./useWebSocket\";\n\n/**\n * AI 응답을 파싱하고 UI에 맞는 메시지 객체로 변환\n */\nconst processAIResponse = result => {\n  if (!result || !result.result) {\n    console.error(\"AI 응답 오류: 결과가 없습니다\", result);\n    return {\n      id: \"error-\" + Date.now(),\n      type: \"assistant\",\n      content: \"처리 중 오류가 발생했습니다. 다시 시도해주세요.\",\n      timestamp: new Date(),\n      isError: true\n    };\n  }\n\n  // LangChain과 직접 통신하므로, 결과가 바로 content가 됨\n  const responseContent = result.result;\n  return {\n    id: \"response-\" + Date.now(),\n    type: \"assistant\",\n    content: responseContent,\n    timestamp: new Date(),\n    // 성능 메트릭 포함\n    performance_metrics: result.performance_metrics,\n    model_info: result.model_info\n  };\n};\n\n/**\n * 채팅 기능을 위한 커스텀 훅\n * @param {string} projectId - 프로젝트 ID\n * @param {string} projectName - 프로젝트 이름\n * @param {Array} promptCards - 프롬프트 카드 배열\n * @returns {Object} - 채팅 관련 상태와 함수들\n */\nexport const useChat = (projectId, projectName, promptCards = []) => {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [inputValue, setInputValue] = useState(\"\");\n  const [copiedMessage, setCopiedMessage] = useState(null);\n  const streamingMessageIdRef = useRef(null);\n  const messagesEndRef = useRef(null);\n  const inputRef = useRef(null);\n  const {\n    isExecuting: isGenerating,\n    isStreaming,\n    executeOrchestration,\n    pollOrchestrationResult,\n    resetOrchestration\n  } = useOrchestration(projectId);\n\n  // WebSocket 훅 추가\n  const {\n    isConnected: wsConnected,\n    isConnecting: wsConnecting,\n    error: wsError,\n    startStreaming: wsStartStreaming,\n    addMessageListener,\n    removeMessageListener\n  } = useWebSocket(projectId);\n\n  // 초기 환영 메시지 설정 - 제거됨 (빈 상태로 시작)\n  useEffect(() => {\n    setMessages([]); // 빈 배열로 시작\n  }, [projectName]);\n\n  // 메시지 추가 시 스크롤 하단으로\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n\n  // WebSocket 메시지 리스너 설정\n  useEffect(() => {\n    const handleWebSocketMessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('WebSocket 메시지 수신:', data);\n        const currentStreamingId = streamingMessageIdRef.current;\n        switch (data.type) {\n          case 'stream_start':\n            console.log('WebSocket 스트리밍 시작');\n            break;\n          case 'progress':\n            console.log(`진행 상황: ${data.step} (${data.progress}%)`);\n            // 진행 상황을 UI에 표시\n            if (currentStreamingId) {\n              setMessages(prev => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n                if (streamingMsgIndex !== -1) {\n                  // LoadingProgress 컴포넌트 형태로 변환\n                  const stage = data.progress <= 25 ? 'initializing' : data.progress <= 50 ? 'analyzing' : data.progress <= 75 ? 'generating' : 'finalizing';\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: data.step,\n                    isLoading: true,\n                    isStreaming: false,\n                    // progress 단계에서는 스트리밍 인디케이터 숨김\n                    loadingProgress: {\n                      stage: stage,\n                      message: data.step,\n                      percentage: data.progress\n                    }\n                  };\n                }\n                return updatedMessages;\n              });\n            }\n            break;\n          case 'stream_chunk':\n            if (currentStreamingId) {\n              setMessages(prev => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n                if (streamingMsgIndex !== -1) {\n                  // 첫 번째 청크인 경우 progress 내용을 초기화\n                  const isFirstChunk = updatedMessages[streamingMsgIndex].loadingProgress !== undefined;\n                  const currentContent = isFirstChunk ? \"\" : updatedMessages[streamingMsgIndex].content;\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: currentContent + data.content,\n                    isLoading: true,\n                    isStreaming: true,\n                    loadingProgress: undefined // progress 상태 제거\n                  };\n                }\n                return updatedMessages;\n              });\n              scrollToBottom();\n            }\n            break;\n          case 'stream_complete':\n            if (currentStreamingId) {\n              setMessages(prev => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n                if (streamingMsgIndex !== -1) {\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: data.fullContent,\n                    isLoading: false,\n                    isStreaming: false,\n                    timestamp: new Date()\n                  };\n                }\n                return updatedMessages;\n              });\n              streamingMessageIdRef.current = null;\n              scrollToBottom();\n            }\n            break;\n          case 'error':\n            console.error('WebSocket 스트리밍 오류:', data.message);\n            if (currentStreamingId) {\n              setMessages(prev => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n                if (streamingMsgIndex !== -1) {\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: '메시지 처리 중 오류가 발생했습니다. 다시 시도해주세요.',\n                    isLoading: false,\n                    isStreaming: false,\n                    isError: true,\n                    timestamp: new Date()\n                  };\n                }\n                return updatedMessages;\n              });\n              streamingMessageIdRef.current = null;\n            }\n            toast.error(data.message);\n            break;\n          default:\n            console.log('알 수 없는 WebSocket 메시지 타입:', data.type);\n        }\n      } catch (error) {\n        console.error('WebSocket 메시지 파싱 오류:', error);\n      }\n    };\n    if (wsConnected) {\n      addMessageListener(handleWebSocketMessage);\n    }\n    return () => {\n      if (wsConnected) {\n        removeMessageListener(handleWebSocketMessage);\n      }\n    };\n  }, [wsConnected, addMessageListener, removeMessageListener, scrollToBottom]);\n  const scrollToBottom = useCallback(() => {\n    var _messagesEndRef$curre;\n    (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({\n      behavior: \"smooth\"\n    });\n  }, []);\n\n  /**\n   * 스트리밍 응답 처리 함수\n   */\n  const handleStreamingResponse = useCallback((chunk, metadata) => {\n    const currentStreamingId = streamingMessageIdRef.current;\n    console.log(\"청크 수신:\", chunk, \"스트리밍 ID:\", currentStreamingId);\n    if (!currentStreamingId) {\n      console.error(\"스트리밍 ID가 없습니다!\");\n      return;\n    }\n    setMessages(prev => {\n      const updatedMessages = [...prev];\n      const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n      if (streamingMsgIndex !== -1) {\n        // 기존 스트리밍 메시지 업데이트\n        updatedMessages[streamingMsgIndex] = {\n          ...updatedMessages[streamingMsgIndex],\n          content: updatedMessages[streamingMsgIndex].content + chunk,\n          isLoading: true,\n          isStreaming: true\n        };\n        console.log(\"스트리밍 메시지 업데이트 성공:\", updatedMessages[streamingMsgIndex].content);\n      } else {\n        console.error(\"스트리밍 메시지를 찾을 수 없음:\", currentStreamingId);\n      }\n      return updatedMessages;\n    });\n\n    // 스크롤 조정\n    scrollToBottom();\n  }, [scrollToBottom]);\n\n  /**\n   * 스트리밍 완료 처리 함수\n   */\n  const handleStreamingComplete = useCallback(result => {\n    const currentStreamingId = streamingMessageIdRef.current;\n    console.log(\"스트리밍 완료:\", result, \"스트리밍 ID:\", currentStreamingId);\n    if (!currentStreamingId) {\n      console.error(\"스트리밍 완료 처리 중 ID가 없습니다!\");\n      return;\n    }\n    setMessages(prev => {\n      const updatedMessages = [...prev];\n      const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n      if (streamingMsgIndex !== -1) {\n        // 스트리밍 메시지 완료 처리\n        updatedMessages[streamingMsgIndex] = {\n          ...updatedMessages[streamingMsgIndex],\n          content: result.result,\n          isLoading: false,\n          isStreaming: false,\n          performance_metrics: result.performance_metrics,\n          model_info: result.model_info,\n          timestamp: new Date()\n        };\n        console.log(\"스트리밍 완료 처리 성공:\", updatedMessages[streamingMsgIndex].content);\n      } else {\n        console.error(\"스트리밍 완료 처리 중 메시지를 찾을 수 없음:\", currentStreamingId);\n      }\n      return updatedMessages;\n    });\n\n    // 스트리밍 ID 초기화\n    streamingMessageIdRef.current = null;\n\n    // 스크롤 조정\n    scrollToBottom();\n  }, [scrollToBottom]);\n\n  /**\n   * 메시지 전송\n   */\n  const handleSendMessage = useCallback(async () => {\n    if (!inputValue.trim() || isGenerating) return;\n    const userMessage = {\n      id: \"user-\" + Date.now(),\n      type: \"user\",\n      content: inputValue.trim(),\n      timestamp: new Date()\n    };\n\n    // 스트리밍 메시지 ID 생성\n    const streamMsgId = \"streaming-\" + Date.now();\n    streamingMessageIdRef.current = streamMsgId;\n    console.log(\"새 스트리밍 메시지 ID 생성:\", streamMsgId);\n\n    // 스트리밍 응답을 위한 초기 메시지\n    const streamingMessage = {\n      id: streamMsgId,\n      type: \"assistant\",\n      content: \"\",\n      timestamp: new Date(),\n      isLoading: true,\n      isStreaming: true\n    };\n    setMessages(prev => [...prev, userMessage, streamingMessage]);\n    setInputValue(\"\");\n    const chatHistory = messages.filter(msg => !msg.isLoading && !msg.isError).map(msg => ({\n      role: msg.type === \"user\" ? \"user\" : \"assistant\",\n      content: msg.content\n    }));\n    try {\n      // WebSocket 연결 확인 및 실시간 스트리밍 시도\n      if (wsConnected) {\n        console.log('WebSocket을 통한 실시간 스트리밍 시작');\n        const success = wsStartStreaming(userMessage.content, chatHistory);\n        if (success) {\n          // WebSocket 스트리밍 성공, 나머지는 리스너에서 처리\n          return;\n        } else {\n          console.log('WebSocket 전송 실패, SSE 폴백 모드로 전환');\n        }\n      } else {\n        console.log('WebSocket 미연결, SSE 모드 사용');\n      }\n\n      // WebSocket 실패 시 기존 SSE 방식으로 폴백\n      const orchestrationData = {\n        userInput: userMessage.content,\n        chat_history: chatHistory\n      };\n\n      // 스트리밍 옵션 설정\n      const streamingOptions = {\n        useStreaming: true,\n        chat_history: orchestrationData.chat_history,\n        onChunk: handleStreamingResponse,\n        onError: error => {\n          console.error(\"스트리밍 오류:\", error);\n          const currentStreamingId = streamingMessageIdRef.current;\n          console.log(\"에러 처리 스트리밍 ID:\", currentStreamingId);\n\n          // 오류 메시지로 변환\n          setMessages(prev => {\n            const updatedMessages = [...prev];\n            const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n            if (streamingMsgIndex !== -1) {\n              updatedMessages[streamingMsgIndex] = {\n                ...updatedMessages[streamingMsgIndex],\n                content: \"메시지 처리 중 오류가 발생했습니다. 다시 시도해주세요.\",\n                isLoading: false,\n                isStreaming: false,\n                isError: true,\n                timestamp: new Date()\n              };\n            }\n            return updatedMessages;\n          });\n          streamingMessageIdRef.current = null;\n        },\n        onComplete: handleStreamingComplete\n      };\n\n      // SSE 스트리밍 방식으로 실행\n      await executeOrchestration(userMessage.content, streamingOptions);\n    } catch (error) {\n      var _error$response;\n      console.error(\"메시지 전송 실패:\", error);\n\n      // 개선된 오류 메시지\n      const errorType = error.code === \"ECONNABORTED\" ? \"timeout\" : \"general\";\n      const errorMessage = {\n        id: \"error-\" + Date.now(),\n        type: \"assistant\",\n        content: errorType === \"timeout\" ? \"처리 시간이 초과되었습니다. 요청이 복잡하거나 서버가 바쁜 상태일 수 있습니다. 잠시 후 다시 시도해주세요.\" : \"메시지 처리 중 오류가 발생했습니다. 네트워크 연결을 확인하고 다시 시도해주세요.\",\n        timestamp: new Date(),\n        isError: true,\n        errorDetails: {\n          type: errorType,\n          message: error.message,\n          status: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status\n        }\n      };\n      setMessages(prev => {\n        // 스트리밍 메시지를 찾아 제거\n        const currentStreamingId = streamingMessageIdRef.current;\n        const filteredMessages = prev.filter(msg => msg.id !== currentStreamingId);\n        return [...filteredMessages, errorMessage];\n      });\n      streamingMessageIdRef.current = null;\n    }\n  }, [inputValue, isGenerating, executeOrchestration, handleStreamingResponse, handleStreamingComplete, messages]);\n\n  /**\n   * Enter 키로 전송\n   */\n  const handleKeyPress = useCallback(e => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSendMessage();\n    }\n  }, [handleSendMessage]);\n\n  /**\n   * 메시지 복사\n   */\n  const handleCopyMessage = useCallback(async (content, messageId) => {\n    const success = await copyToClipboard(content);\n    if (success) {\n      setCopiedMessage(messageId);\n      setTimeout(() => setCopiedMessage(null), 2000);\n    }\n  }, []);\n\n  /**\n   * 개별 제목 복사\n   */\n  const handleCopyTitle = useCallback(async (title, messageId, index) => {\n    const success = await copyToClipboard(title, \"복사되었습니다!\");\n    if (success) {\n      setCopiedMessage(`${messageId}_title_${index}`);\n      setTimeout(() => setCopiedMessage(null), 2000);\n    }\n  }, []);\n\n  /**\n   * 채팅 초기화\n   */\n  const resetChat = useCallback(() => {\n    setMessages([]);\n    setInputValue(\"\");\n    setCopiedMessage(null);\n    streamingMessageIdRef.current = null;\n    resetOrchestration();\n  }, [resetOrchestration]);\n  return {\n    messages,\n    inputValue,\n    setInputValue,\n    copiedMessage,\n    isGenerating,\n    isStreaming,\n    streamingMessageId: streamingMessageIdRef.current,\n    messagesEndRef,\n    inputRef,\n    handleSendMessage,\n    handleKeyPress,\n    handleCopyMessage,\n    handleCopyTitle,\n    resetChat,\n    scrollToBottom,\n    // WebSocket 상태 추가\n    wsConnected,\n    wsConnecting,\n    wsError\n  };\n};\n_s(useChat, \"h5YR2JTSbxndmQb8nrj5/v7ScbM=\", false, function () {\n  return [useOrchestration, useWebSocket];\n});","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","toast","copyToClipboard","useOrchestration","useWebSocket","processAIResponse","result","console","error","id","Date","now","type","content","timestamp","isError","responseContent","performance_metrics","model_info","useChat","projectId","projectName","promptCards","_s","messages","setMessages","inputValue","setInputValue","copiedMessage","setCopiedMessage","streamingMessageIdRef","messagesEndRef","inputRef","isExecuting","isGenerating","isStreaming","executeOrchestration","pollOrchestrationResult","resetOrchestration","isConnected","wsConnected","isConnecting","wsConnecting","wsError","startStreaming","wsStartStreaming","addMessageListener","removeMessageListener","scrollToBottom","handleWebSocketMessage","event","data","JSON","parse","log","currentStreamingId","current","step","progress","prev","updatedMessages","streamingMsgIndex","findIndex","msg","stage","isLoading","loadingProgress","message","percentage","isFirstChunk","undefined","currentContent","fullContent","_messagesEndRef$curre","scrollIntoView","behavior","handleStreamingResponse","chunk","metadata","handleStreamingComplete","handleSendMessage","trim","userMessage","streamMsgId","streamingMessage","chatHistory","filter","map","role","success","orchestrationData","userInput","chat_history","streamingOptions","useStreaming","onChunk","onError","onComplete","_error$response","errorType","code","errorMessage","errorDetails","status","response","filteredMessages","handleKeyPress","e","key","shiftKey","preventDefault","handleCopyMessage","messageId","setTimeout","handleCopyTitle","title","index","resetChat","streamingMessageId"],"sources":["/Users/yeong-gwang/Documents/work/서울경제신문/ai_제목달기(수)_완성본_스트리밍구현 복사본/frontend/src/hooks/useChat.js"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from \"react\";\nimport { toast } from \"react-hot-toast\";\nimport { copyToClipboard } from \"../utils/clipboard\";\nimport { useOrchestration } from \"./useOrchestration\";\nimport { useWebSocket } from \"./useWebSocket\";\n\n/**\n * AI 응답을 파싱하고 UI에 맞는 메시지 객체로 변환\n */\nconst processAIResponse = (result) => {\n  if (!result || !result.result) {\n    console.error(\"AI 응답 오류: 결과가 없습니다\", result);\n    return {\n      id: \"error-\" + Date.now(),\n      type: \"assistant\",\n      content: \"처리 중 오류가 발생했습니다. 다시 시도해주세요.\",\n      timestamp: new Date(),\n      isError: true,\n    };\n  }\n\n  // LangChain과 직접 통신하므로, 결과가 바로 content가 됨\n  const responseContent = result.result;\n\n  return {\n    id: \"response-\" + Date.now(),\n    type: \"assistant\",\n    content: responseContent,\n    timestamp: new Date(),\n    // 성능 메트릭 포함\n    performance_metrics: result.performance_metrics,\n    model_info: result.model_info,\n  };\n};\n\n/**\n * 채팅 기능을 위한 커스텀 훅\n * @param {string} projectId - 프로젝트 ID\n * @param {string} projectName - 프로젝트 이름\n * @param {Array} promptCards - 프롬프트 카드 배열\n * @returns {Object} - 채팅 관련 상태와 함수들\n */\nexport const useChat = (projectId, projectName, promptCards = []) => {\n  const [messages, setMessages] = useState([]);\n  const [inputValue, setInputValue] = useState(\"\");\n  const [copiedMessage, setCopiedMessage] = useState(null);\n  const streamingMessageIdRef = useRef(null);\n\n  const messagesEndRef = useRef(null);\n  const inputRef = useRef(null);\n\n  const {\n    isExecuting: isGenerating,\n    isStreaming,\n    executeOrchestration,\n    pollOrchestrationResult,\n    resetOrchestration,\n  } = useOrchestration(projectId);\n\n  // WebSocket 훅 추가\n  const {\n    isConnected: wsConnected,\n    isConnecting: wsConnecting,\n    error: wsError,\n    startStreaming: wsStartStreaming,\n    addMessageListener,\n    removeMessageListener,\n  } = useWebSocket(projectId);\n\n  // 초기 환영 메시지 설정 - 제거됨 (빈 상태로 시작)\n  useEffect(() => {\n    setMessages([]); // 빈 배열로 시작\n  }, [projectName]);\n\n  // 메시지 추가 시 스크롤 하단으로\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n\n  // WebSocket 메시지 리스너 설정\n  useEffect(() => {\n    const handleWebSocketMessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('WebSocket 메시지 수신:', data);\n\n        const currentStreamingId = streamingMessageIdRef.current;\n\n        switch (data.type) {\n          case 'stream_start':\n            console.log('WebSocket 스트리밍 시작');\n            break;\n\n          case 'progress':\n            console.log(`진행 상황: ${data.step} (${data.progress}%)`);\n            // 진행 상황을 UI에 표시\n            if (currentStreamingId) {\n              setMessages((prev) => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(\n                  (msg) => msg.id === currentStreamingId\n                );\n\n                if (streamingMsgIndex !== -1) {\n                  // LoadingProgress 컴포넌트 형태로 변환\n                  const stage = data.progress <= 25 ? 'initializing' : \n                               data.progress <= 50 ? 'analyzing' : \n                               data.progress <= 75 ? 'generating' : 'finalizing';\n                  \n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: data.step,\n                    isLoading: true,\n                    isStreaming: false, // progress 단계에서는 스트리밍 인디케이터 숨김\n                    loadingProgress: {\n                      stage: stage,\n                      message: data.step,\n                      percentage: data.progress\n                    }\n                  };\n                }\n\n                return updatedMessages;\n              });\n            }\n            break;\n\n          case 'stream_chunk':\n            if (currentStreamingId) {\n              setMessages((prev) => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(\n                  (msg) => msg.id === currentStreamingId\n                );\n\n                if (streamingMsgIndex !== -1) {\n                  // 첫 번째 청크인 경우 progress 내용을 초기화\n                  const isFirstChunk = updatedMessages[streamingMsgIndex].loadingProgress !== undefined;\n                  const currentContent = isFirstChunk ? \"\" : updatedMessages[streamingMsgIndex].content;\n                  \n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: currentContent + data.content,\n                    isLoading: true,\n                    isStreaming: true,\n                    loadingProgress: undefined, // progress 상태 제거\n                  };\n                }\n\n                return updatedMessages;\n              });\n              scrollToBottom();\n            }\n            break;\n\n          case 'stream_complete':\n            if (currentStreamingId) {\n              setMessages((prev) => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(\n                  (msg) => msg.id === currentStreamingId\n                );\n\n                if (streamingMsgIndex !== -1) {\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: data.fullContent,\n                    isLoading: false,\n                    isStreaming: false,\n                    timestamp: new Date(),\n                  };\n                }\n\n                return updatedMessages;\n              });\n              streamingMessageIdRef.current = null;\n              scrollToBottom();\n            }\n            break;\n\n          case 'error':\n            console.error('WebSocket 스트리밍 오류:', data.message);\n            if (currentStreamingId) {\n              setMessages((prev) => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(\n                  (msg) => msg.id === currentStreamingId\n                );\n\n                if (streamingMsgIndex !== -1) {\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: '메시지 처리 중 오류가 발생했습니다. 다시 시도해주세요.',\n                    isLoading: false,\n                    isStreaming: false,\n                    isError: true,\n                    timestamp: new Date(),\n                  };\n                }\n\n                return updatedMessages;\n              });\n              streamingMessageIdRef.current = null;\n            }\n            toast.error(data.message);\n            break;\n\n          default:\n            console.log('알 수 없는 WebSocket 메시지 타입:', data.type);\n        }\n      } catch (error) {\n        console.error('WebSocket 메시지 파싱 오류:', error);\n      }\n    };\n\n    if (wsConnected) {\n      addMessageListener(handleWebSocketMessage);\n    }\n\n    return () => {\n      if (wsConnected) {\n        removeMessageListener(handleWebSocketMessage);\n      }\n    };\n  }, [wsConnected, addMessageListener, removeMessageListener, scrollToBottom]);\n\n  const scrollToBottom = useCallback(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  }, []);\n\n  /**\n   * 스트리밍 응답 처리 함수\n   */\n  const handleStreamingResponse = useCallback(\n    (chunk, metadata) => {\n      const currentStreamingId = streamingMessageIdRef.current;\n      \n      console.log(\"청크 수신:\", chunk, \"스트리밍 ID:\", currentStreamingId);\n      \n      if (!currentStreamingId) {\n        console.error(\"스트리밍 ID가 없습니다!\");\n        return;\n      }\n\n      setMessages((prev) => {\n        const updatedMessages = [...prev];\n        const streamingMsgIndex = updatedMessages.findIndex(\n          (msg) => msg.id === currentStreamingId\n        );\n\n        if (streamingMsgIndex !== -1) {\n          // 기존 스트리밍 메시지 업데이트\n          updatedMessages[streamingMsgIndex] = {\n            ...updatedMessages[streamingMsgIndex],\n            content: updatedMessages[streamingMsgIndex].content + chunk,\n            isLoading: true,\n            isStreaming: true,\n          };\n          console.log(\"스트리밍 메시지 업데이트 성공:\", updatedMessages[streamingMsgIndex].content);\n        } else {\n          console.error(\"스트리밍 메시지를 찾을 수 없음:\", currentStreamingId);\n        }\n\n        return updatedMessages;\n      });\n\n      // 스크롤 조정\n      scrollToBottom();\n    },\n    [scrollToBottom]\n  );\n\n  /**\n   * 스트리밍 완료 처리 함수\n   */\n  const handleStreamingComplete = useCallback(\n    (result) => {\n      const currentStreamingId = streamingMessageIdRef.current;\n      \n      console.log(\"스트리밍 완료:\", result, \"스트리밍 ID:\", currentStreamingId);\n      \n      if (!currentStreamingId) {\n        console.error(\"스트리밍 완료 처리 중 ID가 없습니다!\");\n        return;\n      }\n\n      setMessages((prev) => {\n        const updatedMessages = [...prev];\n        const streamingMsgIndex = updatedMessages.findIndex(\n          (msg) => msg.id === currentStreamingId\n        );\n\n        if (streamingMsgIndex !== -1) {\n          // 스트리밍 메시지 완료 처리\n          updatedMessages[streamingMsgIndex] = {\n            ...updatedMessages[streamingMsgIndex],\n            content: result.result,\n            isLoading: false,\n            isStreaming: false,\n            performance_metrics: result.performance_metrics,\n            model_info: result.model_info,\n            timestamp: new Date(),\n          };\n          console.log(\"스트리밍 완료 처리 성공:\", updatedMessages[streamingMsgIndex].content);\n        } else {\n          console.error(\"스트리밍 완료 처리 중 메시지를 찾을 수 없음:\", currentStreamingId);\n        }\n\n        return updatedMessages;\n      });\n\n      // 스트리밍 ID 초기화\n      streamingMessageIdRef.current = null;\n\n      // 스크롤 조정\n      scrollToBottom();\n    },\n    [scrollToBottom]\n  );\n\n  /**\n   * 메시지 전송\n   */\n  const handleSendMessage = useCallback(async () => {\n    if (!inputValue.trim() || isGenerating) return;\n\n    const userMessage = {\n      id: \"user-\" + Date.now(),\n      type: \"user\",\n      content: inputValue.trim(),\n      timestamp: new Date(),\n    };\n\n    // 스트리밍 메시지 ID 생성\n    const streamMsgId = \"streaming-\" + Date.now();\n    streamingMessageIdRef.current = streamMsgId;\n    \n    console.log(\"새 스트리밍 메시지 ID 생성:\", streamMsgId);\n\n    // 스트리밍 응답을 위한 초기 메시지\n    const streamingMessage = {\n      id: streamMsgId,\n      type: \"assistant\",\n      content: \"\",\n      timestamp: new Date(),\n      isLoading: true,\n      isStreaming: true,\n    };\n\n    setMessages((prev) => [...prev, userMessage, streamingMessage]);\n    setInputValue(\"\");\n\n    const chatHistory = messages\n      .filter((msg) => !msg.isLoading && !msg.isError)\n      .map((msg) => ({\n        role: msg.type === \"user\" ? \"user\" : \"assistant\",\n        content: msg.content,\n      }));\n\n    try {\n      // WebSocket 연결 확인 및 실시간 스트리밍 시도\n      if (wsConnected) {\n        console.log('WebSocket을 통한 실시간 스트리밍 시작');\n        \n        const success = wsStartStreaming(userMessage.content, chatHistory);\n        \n        if (success) {\n          // WebSocket 스트리밍 성공, 나머지는 리스너에서 처리\n          return;\n        } else {\n          console.log('WebSocket 전송 실패, SSE 폴백 모드로 전환');\n        }\n      } else {\n        console.log('WebSocket 미연결, SSE 모드 사용');\n      }\n\n      // WebSocket 실패 시 기존 SSE 방식으로 폴백\n      const orchestrationData = {\n        userInput: userMessage.content,\n        chat_history: chatHistory,\n      };\n\n      // 스트리밍 옵션 설정\n      const streamingOptions = {\n        useStreaming: true,\n        chat_history: orchestrationData.chat_history,\n        onChunk: handleStreamingResponse,\n        onError: (error) => {\n          console.error(\"스트리밍 오류:\", error);\n          \n          const currentStreamingId = streamingMessageIdRef.current;\n          console.log(\"에러 처리 스트리밍 ID:\", currentStreamingId);\n\n          // 오류 메시지로 변환\n          setMessages((prev) => {\n            const updatedMessages = [...prev];\n            const streamingMsgIndex = updatedMessages.findIndex(\n              (msg) => msg.id === currentStreamingId\n            );\n\n            if (streamingMsgIndex !== -1) {\n              updatedMessages[streamingMsgIndex] = {\n                ...updatedMessages[streamingMsgIndex],\n                content:\n                  \"메시지 처리 중 오류가 발생했습니다. 다시 시도해주세요.\",\n                isLoading: false,\n                isStreaming: false,\n                isError: true,\n                timestamp: new Date(),\n              };\n            }\n\n            return updatedMessages;\n          });\n\n          streamingMessageIdRef.current = null;\n        },\n        onComplete: handleStreamingComplete,\n      };\n\n      // SSE 스트리밍 방식으로 실행\n      await executeOrchestration(userMessage.content, streamingOptions);\n    } catch (error) {\n      console.error(\"메시지 전송 실패:\", error);\n\n      // 개선된 오류 메시지\n      const errorType = error.code === \"ECONNABORTED\" ? \"timeout\" : \"general\";\n      const errorMessage = {\n        id: \"error-\" + Date.now(),\n        type: \"assistant\",\n        content:\n          errorType === \"timeout\"\n            ? \"처리 시간이 초과되었습니다. 요청이 복잡하거나 서버가 바쁜 상태일 수 있습니다. 잠시 후 다시 시도해주세요.\"\n            : \"메시지 처리 중 오류가 발생했습니다. 네트워크 연결을 확인하고 다시 시도해주세요.\",\n        timestamp: new Date(),\n        isError: true,\n        errorDetails: {\n          type: errorType,\n          message: error.message,\n          status: error.response?.status,\n        },\n      };\n\n      setMessages((prev) => {\n        // 스트리밍 메시지를 찾아 제거\n        const currentStreamingId = streamingMessageIdRef.current;\n        const filteredMessages = prev.filter(\n          (msg) => msg.id !== currentStreamingId\n        );\n        return [...filteredMessages, errorMessage];\n      });\n\n      streamingMessageIdRef.current = null;\n    }\n  }, [\n    inputValue,\n    isGenerating,\n    executeOrchestration,\n    handleStreamingResponse,\n    handleStreamingComplete,\n    messages,\n  ]);\n\n  /**\n   * Enter 키로 전송\n   */\n  const handleKeyPress = useCallback(\n    (e) => {\n      if (e.key === \"Enter\" && !e.shiftKey) {\n        e.preventDefault();\n        handleSendMessage();\n      }\n    },\n    [handleSendMessage]\n  );\n\n  /**\n   * 메시지 복사\n   */\n  const handleCopyMessage = useCallback(async (content, messageId) => {\n    const success = await copyToClipboard(content);\n    if (success) {\n      setCopiedMessage(messageId);\n      setTimeout(() => setCopiedMessage(null), 2000);\n    }\n  }, []);\n\n  /**\n   * 개별 제목 복사\n   */\n  const handleCopyTitle = useCallback(async (title, messageId, index) => {\n    const success = await copyToClipboard(title, \"복사되었습니다!\");\n    if (success) {\n      setCopiedMessage(`${messageId}_title_${index}`);\n      setTimeout(() => setCopiedMessage(null), 2000);\n    }\n  }, []);\n\n  /**\n   * 채팅 초기화\n   */\n  const resetChat = useCallback(() => {\n    setMessages([]);\n    setInputValue(\"\");\n    setCopiedMessage(null);\n    streamingMessageIdRef.current = null;\n    resetOrchestration();\n  }, [resetOrchestration]);\n\n  return {\n    messages,\n    inputValue,\n    setInputValue,\n    copiedMessage,\n    isGenerating,\n    isStreaming,\n    streamingMessageId: streamingMessageIdRef.current,\n    messagesEndRef,\n    inputRef,\n    handleSendMessage,\n    handleKeyPress,\n    handleCopyMessage,\n    handleCopyTitle,\n    resetChat,\n    scrollToBottom,\n    // WebSocket 상태 추가\n    wsConnected,\n    wsConnecting,\n    wsError,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}