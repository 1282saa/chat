{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from \"react\";\nimport { toast } from \"react-hot-toast\";\nimport { copyToClipboard } from \"../utils/clipboard\";\nimport { useOrchestration } from \"./useOrchestration\";\nimport { useWebSocket } from \"./useWebSocket\";\n\n/**\n * AI 응답을 파싱하고 UI에 맞는 메시지 객체로 변환\n */\nconst processAIResponse = result => {\n  if (!result || !result.result) {\n    console.error(\"AI 응답 오류: 결과가 없습니다\", result);\n    return {\n      id: \"error-\" + Date.now(),\n      type: \"assistant\",\n      content: \"처리 중 오류가 발생했습니다. 다시 시도해주세요.\",\n      timestamp: new Date(),\n      isError: true\n    };\n  }\n\n  // LangChain과 직접 통신하므로, 결과가 바로 content가 됨\n  const responseContent = result.result;\n  return {\n    id: \"response-\" + Date.now(),\n    type: \"assistant\",\n    content: responseContent,\n    timestamp: new Date(),\n    // 성능 메트릭 포함\n    performance_metrics: result.performance_metrics,\n    model_info: result.model_info\n  };\n};\n\n/**\n * 채팅 기능을 위한 커스텀 훅\n * @param {string} projectId - 프로젝트 ID\n * @param {string} projectName - 프로젝트 이름\n * @param {Array} promptCards - 프롬프트 카드 배열\n * @returns {Object} - 채팅 관련 상태와 함수들\n */\nexport const useChat = (projectId, projectName, promptCards = []) => {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [inputValue, setInputValue] = useState(\"\");\n  const [copiedMessage, setCopiedMessage] = useState(null);\n  const [canSendMessage, setCanSendMessage] = useState(true);\n  const [selectedModel, setSelectedModel] = useState(\"anthropic.claude-3-5-sonnet-20241022-v2:0\");\n  const streamingMessageIdRef = useRef(null);\n  const currentWebSocketRef = useRef(null);\n  const currentExecutionIdRef = useRef(null);\n\n  // 청크 배치 처리를 위한 버퍼\n  const chunkBufferRef = useRef(\"\");\n  const batchTimeoutRef = useRef(null);\n  const messagesEndRef = useRef(null);\n  const inputRef = useRef(null);\n\n  // 사용자 스크롤 상태 추적\n  const [isUserScrolling, setIsUserScrolling] = useState(false);\n  const scrollContainerRef = useRef(null);\n  const lastScrollTopRef = useRef(0);\n  const {\n    isExecuting: isGenerating,\n    isStreaming,\n    executeOrchestration,\n    pollOrchestrationResult,\n    resetOrchestration\n  } = useOrchestration(projectId);\n\n  // WebSocket 훅 추가\n  const {\n    isConnected: wsConnected,\n    isConnecting: wsConnecting,\n    error: wsError,\n    startStreaming: wsStartStreaming,\n    addMessageListener,\n    removeMessageListener\n  } = useWebSocket(projectId);\n\n  // 초기 환영 메시지 설정 - 제거됨 (빈 상태로 시작)\n  useEffect(() => {\n    setMessages([]); // 빈 배열로 시작\n  }, [projectName]);\n\n  // 사용자 스크롤 감지 함수\n  const handleScroll = useCallback(() => {\n    if (!scrollContainerRef.current) return;\n    const container = scrollContainerRef.current;\n    const currentScrollTop = container.scrollTop;\n    const maxScrollTop = container.scrollHeight - container.clientHeight;\n\n    // 사용자가 수동으로 스크롤했는지 감지\n    if (Math.abs(currentScrollTop - lastScrollTopRef.current) > 2) {\n      const isAtBottom = currentScrollTop >= maxScrollTop - 20;\n\n      // 하단에 있을 때만 자동 스크롤 허용, 그 외는 사용자 스크롤 모드\n      setIsUserScrolling(!isAtBottom);\n    }\n    lastScrollTopRef.current = currentScrollTop;\n  }, []);\n  const scrollToBottom = useCallback(() => {\n    // 사용자가 스크롤 중이 아닐 때만 자동 스크롤\n    if (!isUserScrolling && messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({\n        behavior: \"smooth\"\n      });\n    }\n  }, [isUserScrolling]);\n\n  // 메시지 추가 시 스크롤 하단으로 (사용자 스크롤 중이 아닐 때만)\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages, scrollToBottom]);\n\n  // WebSocket 메시지 리스너 설정\n  useEffect(() => {\n    const handleWebSocketMessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        // 로깅 최적화: stream_chunk는 로깅 안함\n        if (data.type !== \"stream_chunk\") {\n          console.log(\"WebSocket 메시지 수신:\", data);\n        }\n        const currentStreamingId = streamingMessageIdRef.current;\n        switch (data.type) {\n          case \"stream_start\":\n            console.log(\"WebSocket 스트리밍 시작\");\n            break;\n          case \"progress\":\n            // 진행 상황 로깅 최소화 (10% 단위만)\n            if (data.progress % 10 === 0) {\n              console.log(`진행 상황: ${data.progress}%`);\n            }\n            break;\n          case \"stream_chunk\":\n            if (currentStreamingId) {\n              // 청크 배치 처리로 성능 최적화\n              chunkBufferRef.current += data.content;\n\n              // 기존 타이머 취소\n              if (batchTimeoutRef.current) {\n                clearTimeout(batchTimeoutRef.current);\n              }\n\n              // 50ms 후에 배치 업데이트 (성능 최적화)\n              batchTimeoutRef.current = setTimeout(() => {\n                setMessages(prev => {\n                  const updatedMessages = [...prev];\n                  const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n                  if (streamingMsgIndex !== -1) {\n                    const currentContent = updatedMessages[streamingMsgIndex].content || \"\";\n                    updatedMessages[streamingMsgIndex] = {\n                      ...updatedMessages[streamingMsgIndex],\n                      content: currentContent + chunkBufferRef.current,\n                      isLoading: true,\n                      isStreaming: true\n                    };\n                  }\n                  return updatedMessages;\n                });\n\n                // 버퍼 초기화\n                chunkBufferRef.current = \"\";\n\n                // 스트리밍 중에는 사용자가 스크롤 중이 아닐 때만 자동 스크롤\n                if (!isUserScrolling) {\n                  scrollToBottom();\n                }\n              }, 50); // 50ms 배치 인터벌\n            }\n            break;\n          case \"stream_complete\":\n            if (currentStreamingId) {\n              setMessages(prev => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n                if (streamingMsgIndex !== -1) {\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: data.fullContent,\n                    isLoading: false,\n                    isStreaming: false,\n                    timestamp: new Date()\n                  };\n                }\n                return updatedMessages;\n              });\n              streamingMessageIdRef.current = null;\n              scrollToBottom();\n            }\n            break;\n          case \"error\":\n            console.error(\"WebSocket 스트리밍 오류:\", data.message);\n            if (currentStreamingId) {\n              setMessages(prev => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n                if (streamingMsgIndex !== -1) {\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: \"메시지 처리 중 오류가 발생했습니다. 다시 시도해주세요.\",\n                    isLoading: false,\n                    isStreaming: false,\n                    isError: true,\n                    timestamp: new Date()\n                  };\n                }\n                return updatedMessages;\n              });\n              streamingMessageIdRef.current = null;\n            }\n            toast.error(data.message);\n            break;\n          default:\n            console.log(\"알 수 없는 WebSocket 메시지 타입:\", data.type);\n        }\n      } catch (error) {\n        console.error(\"WebSocket 메시지 파싱 오류:\", error);\n      }\n    };\n    if (wsConnected) {\n      addMessageListener(handleWebSocketMessage);\n    }\n    return () => {\n      if (wsConnected) {\n        removeMessageListener(handleWebSocketMessage);\n      }\n    };\n  }, [wsConnected, addMessageListener, removeMessageListener, scrollToBottom]);\n\n  /**\n   * 스트리밍 응답 처리 함수\n   */\n  const handleStreamingResponse = useCallback((chunk, metadata) => {\n    const currentStreamingId = streamingMessageIdRef.current;\n    console.log(\"청크 수신:\", chunk, \"스트리밍 ID:\", currentStreamingId);\n    if (!currentStreamingId) {\n      console.error(\"스트리밍 ID가 없습니다!\");\n      return;\n    }\n    setMessages(prev => {\n      const updatedMessages = [...prev];\n      const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n      if (streamingMsgIndex !== -1) {\n        // 기존 스트리밍 메시지 업데이트\n        updatedMessages[streamingMsgIndex] = {\n          ...updatedMessages[streamingMsgIndex],\n          content: updatedMessages[streamingMsgIndex].content + chunk,\n          isLoading: true,\n          isStreaming: true\n        };\n        console.log(\"스트리밍 메시지 업데이트 성공:\", updatedMessages[streamingMsgIndex].content);\n      } else {\n        console.error(\"스트리밍 메시지를 찾을 수 없음:\", currentStreamingId);\n      }\n      return updatedMessages;\n    });\n\n    // 스크롤 조정 (사용자가 스크롤 중이 아닐 때만)\n    if (!isUserScrolling) {\n      scrollToBottom();\n    }\n  }, [scrollToBottom, isUserScrolling]);\n\n  /**\n   * 스트리밍 완료 처리 함수\n   */\n  const handleStreamingComplete = useCallback(result => {\n    const currentStreamingId = streamingMessageIdRef.current;\n    console.log(\"스트리밍 완료:\", result, \"스트리밍 ID:\", currentStreamingId);\n    if (!currentStreamingId) {\n      console.error(\"스트리밍 완료 처리 중 ID가 없습니다!\");\n      return;\n    }\n    setMessages(prev => {\n      const updatedMessages = [...prev];\n      const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n      if (streamingMsgIndex !== -1) {\n        // 스트리밍 메시지 완료 처리\n        updatedMessages[streamingMsgIndex] = {\n          ...updatedMessages[streamingMsgIndex],\n          content: result.result,\n          isLoading: false,\n          isStreaming: false,\n          performance_metrics: result.performance_metrics,\n          model_info: result.model_info,\n          timestamp: new Date()\n        };\n        console.log(\"스트리밍 완료 처리 성공:\", updatedMessages[streamingMsgIndex].content);\n      } else {\n        console.error(\"스트리밍 완료 처리 중 메시지를 찾을 수 없음:\", currentStreamingId);\n      }\n      return updatedMessages;\n    });\n\n    // 스트리밍 ID 초기화\n    streamingMessageIdRef.current = null;\n\n    // 입력 활성화\n    console.log(\"WebSocket 스트리밍 완료 - 입력 활성화\");\n    setCanSendMessage(true);\n\n    // 스크롤 조정 (스트리밍 완료 시에는 항상 하단으로)\n    scrollToBottom();\n  }, [scrollToBottom]);\n\n  /**\n   * 스트리밍 중단 함수\n   */\n  const handleStopGeneration = useCallback(() => {\n    console.log(\"생성 중단 요청\");\n\n    // WebSocket 연결 종료\n    if (currentWebSocketRef.current) {\n      currentWebSocketRef.current.close();\n      currentWebSocketRef.current = null;\n    }\n\n    // 현재 실행 중인 작업 중단\n    if (currentExecutionIdRef.current) {\n      // 여기서 실제 API 호출 중단 로직을 추가할 수 있습니다\n      currentExecutionIdRef.current = null;\n    }\n\n    // 스트리밍 메시지 상태 업데이트\n    const currentStreamingId = streamingMessageIdRef.current;\n    if (currentStreamingId) {\n      setMessages(prev => {\n        const updatedMessages = [...prev];\n        const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n        if (streamingMsgIndex !== -1) {\n          updatedMessages[streamingMsgIndex] = {\n            ...updatedMessages[streamingMsgIndex],\n            content: updatedMessages[streamingMsgIndex].content + \"\\n\\n[생성이 중단되었습니다]\",\n            isLoading: false,\n            isStreaming: false,\n            timestamp: new Date()\n          };\n        }\n        return updatedMessages;\n      });\n      streamingMessageIdRef.current = null;\n    }\n\n    // 입력 가능 상태로 복원\n    setCanSendMessage(true);\n\n    // orchestration 상태 리셋\n    resetOrchestration();\n    toast.success(\"생성이 중단되었습니다\");\n  }, [resetOrchestration]);\n\n  /**\n   * 메시지 전송\n   */\n  const handleSendMessage = useCallback(async () => {\n    console.log(\"해들 전송 호출:\", {\n      inputValue: inputValue.trim(),\n      isGenerating,\n      canSendMessage\n    });\n    if (!inputValue.trim() || isGenerating) {\n      console.log(\"전송 중단: 조건 부족\");\n      return;\n    }\n\n    // 입력 비활성화\n    console.log(\"입력 비활성화\");\n    setCanSendMessage(false);\n    const userMessage = {\n      id: \"user-\" + Date.now(),\n      type: \"user\",\n      content: inputValue.trim(),\n      timestamp: new Date()\n    };\n\n    // 스트리밍 메시지 ID 생성\n    const streamMsgId = \"streaming-\" + Date.now();\n    streamingMessageIdRef.current = streamMsgId;\n    console.log(\"새 스트리밍 메시지 ID 생성:\", streamMsgId);\n\n    // 스트리밍 응답을 위한 초기 메시지\n    const streamingMessage = {\n      id: streamMsgId,\n      type: \"assistant\",\n      content: \"\",\n      timestamp: new Date(),\n      isLoading: true,\n      isStreaming: true\n    };\n    setMessages(prev => [...prev, userMessage, streamingMessage]);\n    setInputValue(\"\");\n\n    // 기존 메시지 + 현재 사용자 메시지를 포함한 대화 히스토리 생성\n    const allMessages = [...messages, userMessage];\n    const chatHistory = allMessages.filter(msg => !msg.isLoading && !msg.isError && !msg.isStreaming).map(msg => ({\n      role: msg.type === \"user\" ? \"user\" : \"assistant\",\n      content: msg.content\n    }));\n\n    // 최대 대화 기억 설정 (최근 50개 메시지로 최대 메모리 유지)\n    const maxHistoryLength = 50;\n    const trimmedChatHistory = chatHistory.slice(-maxHistoryLength);\n    console.log(\"대화 히스토리 생성:\", {\n      totalMessages: allMessages.length,\n      fullHistoryLength: chatHistory.length,\n      trimmedHistoryLength: trimmedChatHistory.length,\n      maxHistoryLength: maxHistoryLength,\n      recentHistory: trimmedChatHistory.slice(-6) // 최근 6개만 로그에 표시\n    });\n    try {\n      // 프롬프트 카드 정보 추가 - 활성화된 카드만 필터링하고 백엔드 형식에 맞게 변환\n      const safePromptCards = Array.isArray(promptCards) ? promptCards : [];\n      const activePromptCards = safePromptCards.filter(card => card.isActive !== false && card.enabled !== false).map(card => ({\n        promptId: card.promptId || card.prompt_id,\n        title: card.title || \"Untitled\",\n        prompt_text: card.prompt_text || card.content || \"\",\n        tags: card.tags || [],\n        isActive: card.isActive !== false,\n        stepOrder: card.stepOrder || 0\n      })).filter(card => card.prompt_text.trim()) // 프롬프트 내용이 있는 것만\n      .sort((a, b) => (a.stepOrder || 0) - (b.stepOrder || 0)); // stepOrder로 정렬\n\n      console.log(\"대화 전송 데이터 확인:\", {\n        messageContent: userMessage.content,\n        chatHistoryLength: trimmedChatHistory.length,\n        promptCardsCount: activePromptCards.length,\n        chatHistory: trimmedChatHistory,\n        promptCards: activePromptCards.map(card => ({\n          id: card.promptId,\n          title: card.title,\n          contentLength: card.prompt_text.length,\n          stepOrder: card.stepOrder,\n          hasContent: !!card.prompt_text.trim()\n        }))\n      });\n\n      // WebSocket 연결 확인 및 실시간 스트리밍 시도\n      if (wsConnected) {\n        console.log(\"WebSocket을 통한 실시간 스트리밍 시작\");\n        const success = wsStartStreaming(userMessage.content, trimmedChatHistory, activePromptCards, selectedModel);\n        if (success) {\n          // WebSocket 스트리밍 성공, 나머지는 리스너에서 처리\n          return;\n        } else {\n          console.log(\"WebSocket 전송 실패, SSE 폴백 모드로 전환\");\n        }\n      } else {\n        console.log(\"WebSocket 미연결, SSE 모드 사용\");\n      }\n\n      // WebSocket 실패 시 기존 SSE 방식으로 폴백\n      const orchestrationData = {\n        userInput: userMessage.content,\n        chat_history: trimmedChatHistory,\n        prompt_cards: activePromptCards,\n        modelId: selectedModel\n      };\n      console.log(\"백엔드 전송 데이터 최종 확인:\", orchestrationData);\n\n      // 스트리밍 옵션 설정\n      const streamingOptions = {\n        useStreaming: true,\n        chat_history: orchestrationData.chat_history,\n        prompt_cards: orchestrationData.prompt_cards,\n        modelId: orchestrationData.modelId,\n        onChunk: handleStreamingResponse,\n        onError: error => {\n          console.error(\"스트리밍 오류:\", error);\n          const currentStreamingId = streamingMessageIdRef.current;\n          console.log(\"에러 처리 스트리밍 ID:\", currentStreamingId);\n\n          // 오류 메시지로 변환\n          setMessages(prev => {\n            const updatedMessages = [...prev];\n            const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n            if (streamingMsgIndex !== -1) {\n              updatedMessages[streamingMsgIndex] = {\n                ...updatedMessages[streamingMsgIndex],\n                content: \"메시지 처리 중 오류가 발생했습니다. 다시 시도해주세요.\",\n                isLoading: false,\n                isStreaming: false,\n                isError: true,\n                timestamp: new Date()\n              };\n            }\n            return updatedMessages;\n          });\n          streamingMessageIdRef.current = null;\n        },\n        onComplete: handleStreamingComplete\n      };\n\n      // SSE 스트리밍 방식으로 실행\n      await executeOrchestration(userMessage.content, streamingOptions);\n\n      // SSE 스트리밍 완료 후 입력 활성화\n      console.log(\"SSE 스트리밍 완료 - 입력 활성화\");\n      setCanSendMessage(true);\n    } catch (error) {\n      var _error$response;\n      console.error(\"메시지 전송 실패:\", error);\n\n      // 개선된 오류 메시지\n      const errorType = error.code === \"ECONNABORTED\" ? \"timeout\" : \"general\";\n      const errorMessage = {\n        id: \"error-\" + Date.now(),\n        type: \"assistant\",\n        content: errorType === \"timeout\" ? \"처리 시간이 초과되었습니다. 요청이 복잡하거나 서버가 바쁜 상태일 수 있습니다. 잠시 후 다시 시도해주세요.\" : \"메시지 처리 중 오류가 발생했습니다. 네트워크 연결을 확인하고 다시 시도해주세요.\",\n        timestamp: new Date(),\n        isError: true,\n        errorDetails: {\n          type: errorType,\n          message: error.message,\n          status: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status\n        }\n      };\n      setMessages(prev => {\n        // 스트리밍 메시지를 찾아 제거\n        const currentStreamingId = streamingMessageIdRef.current;\n        const filteredMessages = prev.filter(msg => msg.id !== currentStreamingId);\n        return [...filteredMessages, errorMessage];\n      });\n      streamingMessageIdRef.current = null;\n\n      // 오류 발생 시도 입력 활성화\n      setCanSendMessage(true);\n    }\n\n    // 전체 전송 과정 완료 후 입력 활성화 (보험용)\n    setCanSendMessage(true);\n  }, [inputValue, isGenerating, executeOrchestration, handleStreamingResponse, handleStreamingComplete, messages]);\n\n  /**\n   * Enter 키로 전송\n   */\n  const handleKeyPress = useCallback(e => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSendMessage();\n    }\n  }, [handleSendMessage]);\n\n  /**\n   * 메시지 복사\n   */\n  const handleCopyMessage = useCallback(async (content, messageId) => {\n    const success = await copyToClipboard(content);\n    if (success) {\n      setCopiedMessage(messageId);\n      setTimeout(() => setCopiedMessage(null), 2000);\n    }\n  }, []);\n\n  /**\n   * 개별 제목 복사\n   */\n  const handleCopyTitle = useCallback(async (title, messageId, index) => {\n    const success = await copyToClipboard(title, \"복사되었습니다!\");\n    if (success) {\n      setCopiedMessage(`${messageId}_title_${index}`);\n      setTimeout(() => setCopiedMessage(null), 2000);\n    }\n  }, []);\n\n  /**\n   * 채팅 초기화\n   */\n  const resetChat = useCallback(() => {\n    setMessages([]);\n    setInputValue(\"\");\n    setCopiedMessage(null);\n    setCanSendMessage(true);\n    streamingMessageIdRef.current = null;\n    currentWebSocketRef.current = null;\n    currentExecutionIdRef.current = null;\n    resetOrchestration();\n  }, [resetOrchestration]);\n  return {\n    messages,\n    inputValue,\n    setInputValue,\n    copiedMessage,\n    isGenerating,\n    isStreaming,\n    canSendMessage,\n    streamingMessageId: streamingMessageIdRef.current,\n    messagesEndRef,\n    inputRef,\n    handleSendMessage,\n    handleStopGeneration,\n    handleKeyPress,\n    handleCopyMessage,\n    handleCopyTitle,\n    resetChat,\n    scrollToBottom,\n    // WebSocket 상태 추가\n    wsConnected,\n    wsConnecting,\n    wsError,\n    // 스크롤 관련 추가\n    scrollContainerRef,\n    handleScroll,\n    isUserScrolling,\n    // 모델 선택 관련 추가\n    selectedModel,\n    setSelectedModel\n  };\n};\n_s(useChat, \"Uz90gP/8pAlUPuTkjEBkRNsh4vs=\", false, function () {\n  return [useOrchestration, useWebSocket];\n});","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","toast","copyToClipboard","useOrchestration","useWebSocket","processAIResponse","result","console","error","id","Date","now","type","content","timestamp","isError","responseContent","performance_metrics","model_info","useChat","projectId","projectName","promptCards","_s","messages","setMessages","inputValue","setInputValue","copiedMessage","setCopiedMessage","canSendMessage","setCanSendMessage","selectedModel","setSelectedModel","streamingMessageIdRef","currentWebSocketRef","currentExecutionIdRef","chunkBufferRef","batchTimeoutRef","messagesEndRef","inputRef","isUserScrolling","setIsUserScrolling","scrollContainerRef","lastScrollTopRef","isExecuting","isGenerating","isStreaming","executeOrchestration","pollOrchestrationResult","resetOrchestration","isConnected","wsConnected","isConnecting","wsConnecting","wsError","startStreaming","wsStartStreaming","addMessageListener","removeMessageListener","handleScroll","current","container","currentScrollTop","scrollTop","maxScrollTop","scrollHeight","clientHeight","Math","abs","isAtBottom","scrollToBottom","scrollIntoView","behavior","handleWebSocketMessage","event","data","JSON","parse","log","currentStreamingId","progress","clearTimeout","setTimeout","prev","updatedMessages","streamingMsgIndex","findIndex","msg","currentContent","isLoading","fullContent","message","handleStreamingResponse","chunk","metadata","handleStreamingComplete","handleStopGeneration","close","success","handleSendMessage","trim","userMessage","streamMsgId","streamingMessage","allMessages","chatHistory","filter","map","role","maxHistoryLength","trimmedChatHistory","slice","totalMessages","length","fullHistoryLength","trimmedHistoryLength","recentHistory","safePromptCards","Array","isArray","activePromptCards","card","isActive","enabled","promptId","prompt_id","title","prompt_text","tags","stepOrder","sort","a","b","messageContent","chatHistoryLength","promptCardsCount","contentLength","hasContent","orchestrationData","userInput","chat_history","prompt_cards","modelId","streamingOptions","useStreaming","onChunk","onError","onComplete","_error$response","errorType","code","errorMessage","errorDetails","status","response","filteredMessages","handleKeyPress","e","key","shiftKey","preventDefault","handleCopyMessage","messageId","handleCopyTitle","index","resetChat","streamingMessageId"],"sources":["/Users/yeong-gwang/Documents/work/서울경제신문/ai_제목달기(수)_완성본_스트리밍구현 복사본/frontend/src/hooks/useChat.js"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from \"react\";\nimport { toast } from \"react-hot-toast\";\nimport { copyToClipboard } from \"../utils/clipboard\";\nimport { useOrchestration } from \"./useOrchestration\";\nimport { useWebSocket } from \"./useWebSocket\";\n\n/**\n * AI 응답을 파싱하고 UI에 맞는 메시지 객체로 변환\n */\nconst processAIResponse = (result) => {\n  if (!result || !result.result) {\n    console.error(\"AI 응답 오류: 결과가 없습니다\", result);\n    return {\n      id: \"error-\" + Date.now(),\n      type: \"assistant\",\n      content: \"처리 중 오류가 발생했습니다. 다시 시도해주세요.\",\n      timestamp: new Date(),\n      isError: true,\n    };\n  }\n\n  // LangChain과 직접 통신하므로, 결과가 바로 content가 됨\n  const responseContent = result.result;\n\n  return {\n    id: \"response-\" + Date.now(),\n    type: \"assistant\",\n    content: responseContent,\n    timestamp: new Date(),\n    // 성능 메트릭 포함\n    performance_metrics: result.performance_metrics,\n    model_info: result.model_info,\n  };\n};\n\n/**\n * 채팅 기능을 위한 커스텀 훅\n * @param {string} projectId - 프로젝트 ID\n * @param {string} projectName - 프로젝트 이름\n * @param {Array} promptCards - 프롬프트 카드 배열\n * @returns {Object} - 채팅 관련 상태와 함수들\n */\nexport const useChat = (projectId, projectName, promptCards = []) => {\n  const [messages, setMessages] = useState([]);\n  const [inputValue, setInputValue] = useState(\"\");\n  const [copiedMessage, setCopiedMessage] = useState(null);\n  const [canSendMessage, setCanSendMessage] = useState(true);\n  const [selectedModel, setSelectedModel] = useState(\"anthropic.claude-3-5-sonnet-20241022-v2:0\");\n  const streamingMessageIdRef = useRef(null);\n  const currentWebSocketRef = useRef(null);\n  const currentExecutionIdRef = useRef(null);\n  \n  // 청크 배치 처리를 위한 버퍼\n  const chunkBufferRef = useRef(\"\");\n  const batchTimeoutRef = useRef(null);\n  \n\n  const messagesEndRef = useRef(null);\n  const inputRef = useRef(null);\n\n  // 사용자 스크롤 상태 추적\n  const [isUserScrolling, setIsUserScrolling] = useState(false);\n  const scrollContainerRef = useRef(null);\n  const lastScrollTopRef = useRef(0);\n\n  const {\n    isExecuting: isGenerating,\n    isStreaming,\n    executeOrchestration,\n    pollOrchestrationResult,\n    resetOrchestration,\n  } = useOrchestration(projectId);\n\n  // WebSocket 훅 추가\n  const {\n    isConnected: wsConnected,\n    isConnecting: wsConnecting,\n    error: wsError,\n    startStreaming: wsStartStreaming,\n    addMessageListener,\n    removeMessageListener,\n  } = useWebSocket(projectId);\n\n  // 초기 환영 메시지 설정 - 제거됨 (빈 상태로 시작)\n  useEffect(() => {\n    setMessages([]); // 빈 배열로 시작\n  }, [projectName]);\n\n  // 사용자 스크롤 감지 함수\n  const handleScroll = useCallback(() => {\n    if (!scrollContainerRef.current) return;\n\n    const container = scrollContainerRef.current;\n    const currentScrollTop = container.scrollTop;\n    const maxScrollTop = container.scrollHeight - container.clientHeight;\n\n    // 사용자가 수동으로 스크롤했는지 감지\n    if (Math.abs(currentScrollTop - lastScrollTopRef.current) > 2) {\n      const isAtBottom = currentScrollTop >= maxScrollTop - 20;\n\n      // 하단에 있을 때만 자동 스크롤 허용, 그 외는 사용자 스크롤 모드\n      setIsUserScrolling(!isAtBottom);\n    }\n\n    lastScrollTopRef.current = currentScrollTop;\n  }, []);\n\n  const scrollToBottom = useCallback(() => {\n    // 사용자가 스크롤 중이 아닐 때만 자동 스크롤\n    if (!isUserScrolling && messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({ behavior: \"smooth\" });\n    }\n  }, [isUserScrolling]);\n\n  // 메시지 추가 시 스크롤 하단으로 (사용자 스크롤 중이 아닐 때만)\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages, scrollToBottom]);\n\n  // WebSocket 메시지 리스너 설정\n  useEffect(() => {\n    const handleWebSocketMessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        // 로깅 최적화: stream_chunk는 로깅 안함\n        if (data.type !== \"stream_chunk\") {\n          console.log(\"WebSocket 메시지 수신:\", data);\n        }\n\n        const currentStreamingId = streamingMessageIdRef.current;\n\n        switch (data.type) {\n          case \"stream_start\":\n            console.log(\"WebSocket 스트리밍 시작\");\n            break;\n\n          case \"progress\":\n            // 진행 상황 로깅 최소화 (10% 단위만)\n            if (data.progress % 10 === 0) {\n              console.log(`진행 상황: ${data.progress}%`);\n            }\n            break;\n\n          case \"stream_chunk\":\n            if (currentStreamingId) {\n              // 청크 배치 처리로 성능 최적화\n              chunkBufferRef.current += data.content;\n              \n              // 기존 타이머 취소\n              if (batchTimeoutRef.current) {\n                clearTimeout(batchTimeoutRef.current);\n              }\n              \n              // 50ms 후에 배치 업데이트 (성능 최적화)\n              batchTimeoutRef.current = setTimeout(() => {\n                setMessages((prev) => {\n                  const updatedMessages = [...prev];\n                  const streamingMsgIndex = updatedMessages.findIndex(\n                    (msg) => msg.id === currentStreamingId\n                  );\n\n                  if (streamingMsgIndex !== -1) {\n                    const currentContent =\n                      updatedMessages[streamingMsgIndex].content || \"\";\n\n                    updatedMessages[streamingMsgIndex] = {\n                      ...updatedMessages[streamingMsgIndex],\n                      content: currentContent + chunkBufferRef.current,\n                      isLoading: true,\n                      isStreaming: true,\n                    };\n                  }\n\n                  return updatedMessages;\n                });\n                \n                // 버퍼 초기화\n                chunkBufferRef.current = \"\";\n                \n                // 스트리밍 중에는 사용자가 스크롤 중이 아닐 때만 자동 스크롤\n                if (!isUserScrolling) {\n                  scrollToBottom();\n                }\n              }, 50); // 50ms 배치 인터벌\n            }\n            break;\n\n          case \"stream_complete\":\n            if (currentStreamingId) {\n              setMessages((prev) => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(\n                  (msg) => msg.id === currentStreamingId\n                );\n\n                if (streamingMsgIndex !== -1) {\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: data.fullContent,\n                    isLoading: false,\n                    isStreaming: false,\n                    timestamp: new Date(),\n                  };\n                }\n\n                return updatedMessages;\n              });\n              streamingMessageIdRef.current = null;\n              scrollToBottom();\n            }\n            break;\n\n          case \"error\":\n            console.error(\"WebSocket 스트리밍 오류:\", data.message);\n            if (currentStreamingId) {\n              setMessages((prev) => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(\n                  (msg) => msg.id === currentStreamingId\n                );\n\n                if (streamingMsgIndex !== -1) {\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content:\n                      \"메시지 처리 중 오류가 발생했습니다. 다시 시도해주세요.\",\n                    isLoading: false,\n                    isStreaming: false,\n                    isError: true,\n                    timestamp: new Date(),\n                  };\n                }\n\n                return updatedMessages;\n              });\n              streamingMessageIdRef.current = null;\n            }\n            toast.error(data.message);\n            break;\n\n          default:\n            console.log(\"알 수 없는 WebSocket 메시지 타입:\", data.type);\n        }\n      } catch (error) {\n        console.error(\"WebSocket 메시지 파싱 오류:\", error);\n      }\n    };\n\n    if (wsConnected) {\n      addMessageListener(handleWebSocketMessage);\n    }\n\n    return () => {\n      if (wsConnected) {\n        removeMessageListener(handleWebSocketMessage);\n      }\n    };\n  }, [wsConnected, addMessageListener, removeMessageListener, scrollToBottom]);\n\n  /**\n   * 스트리밍 응답 처리 함수\n   */\n  const handleStreamingResponse = useCallback(\n    (chunk, metadata) => {\n      const currentStreamingId = streamingMessageIdRef.current;\n\n      console.log(\"청크 수신:\", chunk, \"스트리밍 ID:\", currentStreamingId);\n\n      if (!currentStreamingId) {\n        console.error(\"스트리밍 ID가 없습니다!\");\n        return;\n      }\n\n      setMessages((prev) => {\n        const updatedMessages = [...prev];\n        const streamingMsgIndex = updatedMessages.findIndex(\n          (msg) => msg.id === currentStreamingId\n        );\n\n        if (streamingMsgIndex !== -1) {\n          // 기존 스트리밍 메시지 업데이트\n          updatedMessages[streamingMsgIndex] = {\n            ...updatedMessages[streamingMsgIndex],\n            content: updatedMessages[streamingMsgIndex].content + chunk,\n            isLoading: true,\n            isStreaming: true,\n          };\n          console.log(\n            \"스트리밍 메시지 업데이트 성공:\",\n            updatedMessages[streamingMsgIndex].content\n          );\n        } else {\n          console.error(\"스트리밍 메시지를 찾을 수 없음:\", currentStreamingId);\n        }\n\n        return updatedMessages;\n      });\n\n      // 스크롤 조정 (사용자가 스크롤 중이 아닐 때만)\n      if (!isUserScrolling) {\n        scrollToBottom();\n      }\n    },\n    [scrollToBottom, isUserScrolling]\n  );\n\n  /**\n   * 스트리밍 완료 처리 함수\n   */\n  const handleStreamingComplete = useCallback(\n    (result) => {\n      const currentStreamingId = streamingMessageIdRef.current;\n\n      console.log(\"스트리밍 완료:\", result, \"스트리밍 ID:\", currentStreamingId);\n\n      if (!currentStreamingId) {\n        console.error(\"스트리밍 완료 처리 중 ID가 없습니다!\");\n        return;\n      }\n\n      setMessages((prev) => {\n        const updatedMessages = [...prev];\n        const streamingMsgIndex = updatedMessages.findIndex(\n          (msg) => msg.id === currentStreamingId\n        );\n\n        if (streamingMsgIndex !== -1) {\n          // 스트리밍 메시지 완료 처리\n          updatedMessages[streamingMsgIndex] = {\n            ...updatedMessages[streamingMsgIndex],\n            content: result.result,\n            isLoading: false,\n            isStreaming: false,\n            performance_metrics: result.performance_metrics,\n            model_info: result.model_info,\n            timestamp: new Date(),\n          };\n          console.log(\n            \"스트리밍 완료 처리 성공:\",\n            updatedMessages[streamingMsgIndex].content\n          );\n        } else {\n          console.error(\n            \"스트리밍 완료 처리 중 메시지를 찾을 수 없음:\",\n            currentStreamingId\n          );\n        }\n\n        return updatedMessages;\n      });\n\n      // 스트리밍 ID 초기화\n      streamingMessageIdRef.current = null;\n\n      // 입력 활성화\n      console.log(\"WebSocket 스트리밍 완료 - 입력 활성화\");\n      setCanSendMessage(true);\n\n      // 스크롤 조정 (스트리밍 완료 시에는 항상 하단으로)\n      scrollToBottom();\n    },\n    [scrollToBottom]\n  );\n\n  /**\n   * 스트리밍 중단 함수\n   */\n  const handleStopGeneration = useCallback(() => {\n    console.log(\"생성 중단 요청\");\n\n    // WebSocket 연결 종료\n    if (currentWebSocketRef.current) {\n      currentWebSocketRef.current.close();\n      currentWebSocketRef.current = null;\n    }\n\n    // 현재 실행 중인 작업 중단\n    if (currentExecutionIdRef.current) {\n      // 여기서 실제 API 호출 중단 로직을 추가할 수 있습니다\n      currentExecutionIdRef.current = null;\n    }\n\n    // 스트리밍 메시지 상태 업데이트\n    const currentStreamingId = streamingMessageIdRef.current;\n    if (currentStreamingId) {\n      setMessages((prev) => {\n        const updatedMessages = [...prev];\n        const streamingMsgIndex = updatedMessages.findIndex(\n          (msg) => msg.id === currentStreamingId\n        );\n\n        if (streamingMsgIndex !== -1) {\n          updatedMessages[streamingMsgIndex] = {\n            ...updatedMessages[streamingMsgIndex],\n            content:\n              updatedMessages[streamingMsgIndex].content +\n              \"\\n\\n[생성이 중단되었습니다]\",\n            isLoading: false,\n            isStreaming: false,\n            timestamp: new Date(),\n          };\n        }\n\n        return updatedMessages;\n      });\n\n      streamingMessageIdRef.current = null;\n    }\n\n    // 입력 가능 상태로 복원\n    setCanSendMessage(true);\n\n    // orchestration 상태 리셋\n    resetOrchestration();\n\n    toast.success(\"생성이 중단되었습니다\");\n  }, [resetOrchestration]);\n\n  /**\n   * 메시지 전송\n   */\n  const handleSendMessage = useCallback(async () => {\n    console.log(\"해들 전송 호출:\", {\n      inputValue: inputValue.trim(),\n      isGenerating,\n      canSendMessage,\n    });\n\n    if (!inputValue.trim() || isGenerating) {\n      console.log(\"전송 중단: 조건 부족\");\n      return;\n    }\n\n    // 입력 비활성화\n    console.log(\"입력 비활성화\");\n    setCanSendMessage(false);\n\n    const userMessage = {\n      id: \"user-\" + Date.now(),\n      type: \"user\",\n      content: inputValue.trim(),\n      timestamp: new Date(),\n    };\n\n    // 스트리밍 메시지 ID 생성\n    const streamMsgId = \"streaming-\" + Date.now();\n    streamingMessageIdRef.current = streamMsgId;\n\n    console.log(\"새 스트리밍 메시지 ID 생성:\", streamMsgId);\n\n    // 스트리밍 응답을 위한 초기 메시지\n    const streamingMessage = {\n      id: streamMsgId,\n      type: \"assistant\",\n      content: \"\",\n      timestamp: new Date(),\n      isLoading: true,\n      isStreaming: true,\n    };\n\n    setMessages((prev) => [...prev, userMessage, streamingMessage]);\n    setInputValue(\"\");\n\n    // 기존 메시지 + 현재 사용자 메시지를 포함한 대화 히스토리 생성\n    const allMessages = [...messages, userMessage];\n    const chatHistory = allMessages\n      .filter((msg) => !msg.isLoading && !msg.isError && !msg.isStreaming)\n      .map((msg) => ({\n        role: msg.type === \"user\" ? \"user\" : \"assistant\",\n        content: msg.content,\n      }));\n\n    // 최대 대화 기억 설정 (최근 50개 메시지로 최대 메모리 유지)\n    const maxHistoryLength = 50;\n    const trimmedChatHistory = chatHistory.slice(-maxHistoryLength);\n\n    console.log(\"대화 히스토리 생성:\", {\n      totalMessages: allMessages.length,\n      fullHistoryLength: chatHistory.length,\n      trimmedHistoryLength: trimmedChatHistory.length,\n      maxHistoryLength: maxHistoryLength,\n      recentHistory: trimmedChatHistory.slice(-6), // 최근 6개만 로그에 표시\n    });\n\n    try {\n      // 프롬프트 카드 정보 추가 - 활성화된 카드만 필터링하고 백엔드 형식에 맞게 변환\n      const safePromptCards = Array.isArray(promptCards) ? promptCards : [];\n      const activePromptCards = safePromptCards\n        .filter((card) => card.isActive !== false && card.enabled !== false)\n        .map((card) => ({\n          promptId: card.promptId || card.prompt_id,\n          title: card.title || \"Untitled\",\n          prompt_text: card.prompt_text || card.content || \"\",\n          tags: card.tags || [],\n          isActive: card.isActive !== false,\n          stepOrder: card.stepOrder || 0,\n        }))\n        .filter((card) => card.prompt_text.trim()) // 프롬프트 내용이 있는 것만\n        .sort((a, b) => (a.stepOrder || 0) - (b.stepOrder || 0)); // stepOrder로 정렬\n\n      console.log(\"대화 전송 데이터 확인:\", {\n        messageContent: userMessage.content,\n        chatHistoryLength: trimmedChatHistory.length,\n        promptCardsCount: activePromptCards.length,\n        chatHistory: trimmedChatHistory,\n        promptCards: activePromptCards.map((card) => ({\n          id: card.promptId,\n          title: card.title,\n          contentLength: card.prompt_text.length,\n          stepOrder: card.stepOrder,\n          hasContent: !!card.prompt_text.trim(),\n        })),\n      });\n\n      // WebSocket 연결 확인 및 실시간 스트리밍 시도\n      if (wsConnected) {\n        console.log(\"WebSocket을 통한 실시간 스트리밍 시작\");\n\n        const success = wsStartStreaming(\n          userMessage.content,\n          trimmedChatHistory,\n          activePromptCards,\n          selectedModel\n        );\n\n        if (success) {\n          // WebSocket 스트리밍 성공, 나머지는 리스너에서 처리\n          return;\n        } else {\n          console.log(\"WebSocket 전송 실패, SSE 폴백 모드로 전환\");\n        }\n      } else {\n        console.log(\"WebSocket 미연결, SSE 모드 사용\");\n      }\n\n      // WebSocket 실패 시 기존 SSE 방식으로 폴백\n      const orchestrationData = {\n        userInput: userMessage.content,\n        chat_history: trimmedChatHistory,\n        prompt_cards: activePromptCards,\n        modelId: selectedModel,\n      };\n\n      console.log(\"백엔드 전송 데이터 최종 확인:\", orchestrationData);\n\n      // 스트리밍 옵션 설정\n      const streamingOptions = {\n        useStreaming: true,\n        chat_history: orchestrationData.chat_history,\n        prompt_cards: orchestrationData.prompt_cards,\n        modelId: orchestrationData.modelId,\n        onChunk: handleStreamingResponse,\n        onError: (error) => {\n          console.error(\"스트리밍 오류:\", error);\n\n          const currentStreamingId = streamingMessageIdRef.current;\n          console.log(\"에러 처리 스트리밍 ID:\", currentStreamingId);\n\n          // 오류 메시지로 변환\n          setMessages((prev) => {\n            const updatedMessages = [...prev];\n            const streamingMsgIndex = updatedMessages.findIndex(\n              (msg) => msg.id === currentStreamingId\n            );\n\n            if (streamingMsgIndex !== -1) {\n              updatedMessages[streamingMsgIndex] = {\n                ...updatedMessages[streamingMsgIndex],\n                content:\n                  \"메시지 처리 중 오류가 발생했습니다. 다시 시도해주세요.\",\n                isLoading: false,\n                isStreaming: false,\n                isError: true,\n                timestamp: new Date(),\n              };\n            }\n\n            return updatedMessages;\n          });\n\n          streamingMessageIdRef.current = null;\n        },\n        onComplete: handleStreamingComplete,\n      };\n\n      // SSE 스트리밍 방식으로 실행\n      await executeOrchestration(userMessage.content, streamingOptions);\n\n      // SSE 스트리밍 완료 후 입력 활성화\n      console.log(\"SSE 스트리밍 완료 - 입력 활성화\");\n      setCanSendMessage(true);\n    } catch (error) {\n      console.error(\"메시지 전송 실패:\", error);\n\n      // 개선된 오류 메시지\n      const errorType = error.code === \"ECONNABORTED\" ? \"timeout\" : \"general\";\n      const errorMessage = {\n        id: \"error-\" + Date.now(),\n        type: \"assistant\",\n        content:\n          errorType === \"timeout\"\n            ? \"처리 시간이 초과되었습니다. 요청이 복잡하거나 서버가 바쁜 상태일 수 있습니다. 잠시 후 다시 시도해주세요.\"\n            : \"메시지 처리 중 오류가 발생했습니다. 네트워크 연결을 확인하고 다시 시도해주세요.\",\n        timestamp: new Date(),\n        isError: true,\n        errorDetails: {\n          type: errorType,\n          message: error.message,\n          status: error.response?.status,\n        },\n      };\n\n      setMessages((prev) => {\n        // 스트리밍 메시지를 찾아 제거\n        const currentStreamingId = streamingMessageIdRef.current;\n        const filteredMessages = prev.filter(\n          (msg) => msg.id !== currentStreamingId\n        );\n        return [...filteredMessages, errorMessage];\n      });\n\n      streamingMessageIdRef.current = null;\n\n      // 오류 발생 시도 입력 활성화\n      setCanSendMessage(true);\n    }\n\n    // 전체 전송 과정 완료 후 입력 활성화 (보험용)\n    setCanSendMessage(true);\n  }, [\n    inputValue,\n    isGenerating,\n    executeOrchestration,\n    handleStreamingResponse,\n    handleStreamingComplete,\n    messages,\n  ]);\n\n  /**\n   * Enter 키로 전송\n   */\n  const handleKeyPress = useCallback(\n    (e) => {\n      if (e.key === \"Enter\" && !e.shiftKey) {\n        e.preventDefault();\n        handleSendMessage();\n      }\n    },\n    [handleSendMessage]\n  );\n\n  /**\n   * 메시지 복사\n   */\n  const handleCopyMessage = useCallback(async (content, messageId) => {\n    const success = await copyToClipboard(content);\n    if (success) {\n      setCopiedMessage(messageId);\n      setTimeout(() => setCopiedMessage(null), 2000);\n    }\n  }, []);\n\n  /**\n   * 개별 제목 복사\n   */\n  const handleCopyTitle = useCallback(async (title, messageId, index) => {\n    const success = await copyToClipboard(title, \"복사되었습니다!\");\n    if (success) {\n      setCopiedMessage(`${messageId}_title_${index}`);\n      setTimeout(() => setCopiedMessage(null), 2000);\n    }\n  }, []);\n\n  /**\n   * 채팅 초기화\n   */\n  const resetChat = useCallback(() => {\n    setMessages([]);\n    setInputValue(\"\");\n    setCopiedMessage(null);\n    setCanSendMessage(true);\n    streamingMessageIdRef.current = null;\n    currentWebSocketRef.current = null;\n    currentExecutionIdRef.current = null;\n    resetOrchestration();\n  }, [resetOrchestration]);\n\n  return {\n    messages,\n    inputValue,\n    setInputValue,\n    copiedMessage,\n    isGenerating,\n    isStreaming,\n    canSendMessage,\n    streamingMessageId: streamingMessageIdRef.current,\n    messagesEndRef,\n    inputRef,\n    handleSendMessage,\n    handleStopGeneration,\n    handleKeyPress,\n    handleCopyMessage,\n    handleCopyTitle,\n    resetChat,\n    scrollToBottom,\n    // WebSocket 상태 추가\n    wsConnected,\n    wsConnecting,\n    wsError,\n    // 스크롤 관련 추가\n    scrollContainerRef,\n    handleScroll,\n    isUserScrolling,\n    // 모델 선택 관련 추가\n    selectedModel,\n    setSelectedModel,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}