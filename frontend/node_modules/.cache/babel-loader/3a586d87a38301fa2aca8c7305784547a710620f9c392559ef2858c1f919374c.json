{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from \"react\";\nimport { toast } from \"react-hot-toast\";\nimport { copyToClipboard } from \"../utils/clipboard\";\nimport { useOrchestration } from \"./useOrchestration\";\nimport { useWebSocket } from \"./useWebSocket\";\nimport { crewAPI, handleAPIError } from \"../services/api\";\nimport { useAuth } from \"../contexts/AuthContext\";\n\n/**\n * 멀티-에이전트 AI 응답을 파싱하고 UI에 맞는 메시지 객체로 변환\n */\nconst processMultiAgentResponse = result => {\n  if (!result) {\n    console.error(\"멀티-에이전트 응답 오류: 결과가 없습니다\", result);\n    return {\n      id: \"error-\" + Date.now(),\n      type: \"assistant\",\n      content: \"처리 중 오류가 발생했습니다. 다시 시도해주세요.\",\n      timestamp: new Date().toISOString(),\n      isError: true\n    };\n  }\n\n  // 멀티-에이전트 결과 구성\n  const agentResults = result.agentResults || {};\n  const finalTitles = result.finalTitles || {};\n  const tokenUsage = result.tokenUsage || 0;\n\n  // 에이전트별 결과를 포맷팅\n  const agentSummary = Object.keys(agentResults).map(agentType => {\n    const agentResult = agentResults[agentType];\n    const titles = finalTitles[agentType] || [];\n    return {\n      agentType,\n      agentName: getAgentName(agentType),\n      result: (agentResult === null || agentResult === void 0 ? void 0 : agentResult.content) || \"결과 없음\",\n      titles: titles,\n      tokenCount: (agentResult === null || agentResult === void 0 ? void 0 : agentResult.tokenCount) || 0\n    };\n  });\n\n  // 전체 제목 목록 생성\n  const allTitles = Object.values(finalTitles).flat();\n  return {\n    id: \"multi-agent-\" + Date.now(),\n    type: \"assistant\",\n    content: formatMultiAgentContent(agentSummary, allTitles),\n    timestamp: new Date(),\n    // 멀티-에이전트 특화 데이터\n    isMultiAgent: true,\n    agentResults: agentSummary,\n    allTitles: allTitles,\n    tokenUsage: tokenUsage\n  };\n};\n\n/**\n * 에이전트 타입을 한국어 이름으로 변환\n */\nconst getAgentName = agentType => {\n  const agentNames = {\n    journalism: \"📰 저널리즘 충실형\",\n    balanced: \"⚖️ 균형잡힌 후킹형\",\n    click: \"🎯 클릭유도형\",\n    seo: \"🔍 SEO/AEO 최적화형\",\n    social: \"📱 소셜미디어 공유형\"\n  };\n  return agentNames[agentType] || `🤖 ${agentType}`;\n};\n\n/**\n * 멀티-에이전트 결과를 UI 표시용 텍스트로 포맷팅\n */\nconst formatMultiAgentContent = (agentSummary, allTitles) => {\n  let content = \"🚀 **멀티-에이전트 분석 완료**\\n\\n\";\n\n  // 전체 제목 요약\n  if (allTitles.length > 0) {\n    content += \"📋 **생성된 제목 목록:**\\n\";\n    allTitles.forEach((title, index) => {\n      content += `${index + 1}. ${title}\\n`;\n    });\n    content += \"\\n\";\n  }\n\n  // 에이전트별 상세 결과\n  content += \"🔍 **에이전트별 분석 결과:**\\n\\n\";\n  agentSummary.forEach(agent => {\n    content += `### ${agent.agentName}\\n`;\n    if (agent.titles.length > 0) {\n      content += \"**생성 제목:**\\n\";\n      agent.titles.forEach(title => {\n        content += `• ${title}\\n`;\n      });\n    }\n    content += `**토큰 사용량:** ${agent.tokenCount}개\\n\\n`;\n  });\n  return content;\n};\n\n/**\n * 채팅 기능을 위한 커스텀 훅\n * @param {string} projectId - 프로젝트 ID\n * @param {string} projectName - 프로젝트 이름\n * @param {Array} promptCards - 프롬프트 카드 배열\n * @returns {Object} - 채팅 관련 상태와 함수들\n */\nexport const useChat = (projectId, projectName, promptCards = [], conversationId = null, createConversationFn = null, setCurrentConversationFn = null) => {\n  _s();\n  const {\n    user\n  } = useAuth(); // Add user from AuthContext\n\n  // 디버깅 로그 (첫 번째 렌더링에만)\n  const isFirstRender = useRef(true);\n  if (isFirstRender.current) {\n    console.log(\"🔍 [DEBUG] useChat 초기화:\", {\n      projectId,\n      projectName,\n      promptCardsLength: promptCards === null || promptCards === void 0 ? void 0 : promptCards.length,\n      conversationId,\n      conversationIdType: typeof conversationId,\n      isConversationIdNull: conversationId === null,\n      isConversationIdUndefined: conversationId === undefined,\n      userId: user === null || user === void 0 ? void 0 : user.id\n    });\n    isFirstRender.current = false;\n  }\n\n  // conversationId 변경 감지\n  useEffect(() => {\n    console.log(\"🔍 [DEBUG] useChat - conversationId 변경:\", {\n      newConversationId: conversationId,\n      conversationIdType: typeof conversationId,\n      isNull: conversationId === null,\n      isUndefined: conversationId === undefined\n    });\n  }, [conversationId]);\n  const [messages, setMessages] = useState([]);\n  const [inputValue, setInputValue] = useState(\"\");\n  const [copiedMessage, setCopiedMessage] = useState(null);\n  const [canSendMessage, setCanSendMessage] = useState(true);\n  const [inputHeight, setInputHeight] = useState(24); // 동적 높이 관리\n  const [selectedModel, setSelectedModel] = useState(\"anthropic.claude-3-5-sonnet-20241022-v2:0\");\n  const streamingMessageIdRef = useRef(null);\n  const currentWebSocketRef = useRef(null);\n  const currentExecutionIdRef = useRef(null);\n  const messagesEndRef = useRef(null);\n  const inputRef = useRef(null);\n\n  // 사용자 스크롤 상태 추적\n  const [isUserScrolling, setIsUserScrolling] = useState(false);\n  const scrollContainerRef = useRef(null);\n  const lastScrollTopRef = useRef(0);\n  const {\n    isExecuting: isGenerating,\n    isStreaming,\n    executeOrchestration,\n    resetOrchestration\n  } = useOrchestration(projectId);\n\n  // WebSocket 훅 추가\n  const {\n    isConnected: wsConnected,\n    isConnecting: wsConnecting,\n    error: wsError,\n    startStreaming: wsStartStreaming,\n    addMessageListener,\n    removeMessageListener\n  } = useWebSocket(projectId);\n\n  // 초기 메시지 설정 - projectId 또는 conversationId 변경시 초기화\n  useEffect(() => {\n    console.log(\"🔍 [DEBUG] useChat 메시지 초기화:\", {\n      projectId,\n      conversationId,\n      previousMessages: messages.length\n    });\n    setMessages([]); // 빈 배열로 시작\n  }, [projectId, conversationId]); // conversationId 추가\n\n  // 사용자 스크롤 감지 함수\n  const handleScroll = useCallback(() => {\n    if (!scrollContainerRef.current) return;\n    const container = scrollContainerRef.current;\n    const currentScrollTop = container.scrollTop;\n    const maxScrollTop = container.scrollHeight - container.clientHeight;\n\n    // 사용자가 수동으로 스크롤했는지 감지\n    if (Math.abs(currentScrollTop - lastScrollTopRef.current) > 2) {\n      const isAtBottom = currentScrollTop >= maxScrollTop - 20;\n\n      // 하단에 있을 때만 자동 스크롤 허용, 그 외는 사용자 스크롤 모드\n      setIsUserScrolling(!isAtBottom);\n    }\n    lastScrollTopRef.current = currentScrollTop;\n  }, []);\n  const scrollToBottom = useCallback(() => {\n    // 사용자가 스크롤 중이 아닐 때만 자동 스크롤\n    if (!isUserScrolling && messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({\n        behavior: \"smooth\"\n      });\n    }\n  }, [isUserScrolling]);\n\n  // 메시지 추가 시 스크롤 하단으로 (사용자 스크롤 중이 아닐 때만)\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages, scrollToBottom]);\n\n  // WebSocket 메시지 리스너 설정\n  useEffect(() => {\n    const handleWebSocketMessage = event => {\n      var _data$message7;\n      try {\n        const data = JSON.parse(event.data);\n        console.log(\"WebSocket 메시지 수신:\", data);\n        const currentStreamingId = streamingMessageIdRef.current;\n        switch (data.type) {\n          case \"stream_start\":\n            console.log(\"WebSocket 스트리밍 시작\");\n            break;\n          case \"progress\":\n            // 진행 상황 로그만 남기고 UI 업데이트는 제거\n            console.log(`진행 상황: ${data.step} (${data.progress}%)`);\n            break;\n          case \"stream_chunk\":\n            if (currentStreamingId) {\n              setMessages(prev => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n                console.log(\"스트림 청크 처리:\", {\n                  currentStreamingId,\n                  streamingMsgIndex,\n                  messagesLength: prev.length,\n                  content: data.content\n                });\n                if (streamingMsgIndex !== -1) {\n                  // 기존 내용에 새 청크 추가\n                  const currentContent = updatedMessages[streamingMsgIndex].content || \"\";\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: currentContent + data.content,\n                    isLoading: true,\n                    isStreaming: true\n                  };\n                  console.log(\"메시지 업데이트됨:\", updatedMessages[streamingMsgIndex]);\n                } else {\n                  console.log(\"스트리밍 메시지를 찾을 수 없음, 메시지 ID들:\", prev.map(m => m.id));\n                }\n                return updatedMessages;\n              });\n              // 스트리밍 중에는 사용자가 스크롤 중이 아닐 때만 자동 스크롤\n              if (!isUserScrolling) {\n                scrollToBottom();\n              }\n            } else {\n              console.log(\"currentStreamingId가 null임\");\n            }\n            break;\n          case \"stream_complete\":\n            if (currentStreamingId) {\n              setMessages(prev => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n                if (streamingMsgIndex !== -1) {\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: data.fullContent,\n                    isLoading: false,\n                    isStreaming: false,\n                    timestamp: new Date().toISOString()\n                  };\n                }\n                return updatedMessages;\n              });\n              streamingMessageIdRef.current = null;\n              scrollToBottom();\n            }\n            break;\n          case \"error\":\n            console.error(\"WebSocket 스트리밍 오류:\", data.message);\n            if (currentStreamingId) {\n              setMessages(prev => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n                if (streamingMsgIndex !== -1) {\n                  var _data$message, _data$message2, _data$message3, _data$message4, _data$message5, _data$message6;\n                  // 오류 유형에 따른 사용자 메시지 결정\n                  let errorContent = \"메시지 처리 중 오류가 발생했습니다. 다시 시도해주세요.\";\n                  if ((_data$message = data.message) !== null && _data$message !== void 0 && _data$message.includes(\"401\") || (_data$message2 = data.message) !== null && _data$message2 !== void 0 && _data$message2.includes(\"Unauthorized\")) {\n                    errorContent = \"인증이 만료되었습니다. 다시 로그인해주세요.\";\n                  } else if ((_data$message3 = data.message) !== null && _data$message3 !== void 0 && _data$message3.includes(\"timeout\") || (_data$message4 = data.message) !== null && _data$message4 !== void 0 && _data$message4.includes(\"시간 초과\")) {\n                    errorContent = \"처리 시간이 초과되었습니다. 요청을 단순화하거나 잠시 후 다시 시도해주세요.\";\n                  } else if ((_data$message5 = data.message) !== null && _data$message5 !== void 0 && _data$message5.includes(\"rate limit\") || (_data$message6 = data.message) !== null && _data$message6 !== void 0 && _data$message6.includes(\"제한\")) {\n                    errorContent = \"요청 한도에 도달했습니다. 잠시 후 다시 시도해주세요.\";\n                  }\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: errorContent,\n                    isLoading: false,\n                    isStreaming: false,\n                    isError: true,\n                    timestamp: new Date().toISOString()\n                  };\n                }\n                return updatedMessages;\n              });\n              streamingMessageIdRef.current = null;\n            }\n\n            // 사용자 친화적인 토스트 메시지\n            const toastMessage = (_data$message7 = data.message) !== null && _data$message7 !== void 0 && _data$message7.includes(\"401\") ? \"인증이 만료되었습니다\" : \"처리 중 오류가 발생했습니다\";\n            toast.error(toastMessage);\n            break;\n          default:\n            console.log(\"알 수 없는 WebSocket 메시지 타입:\", data.type);\n        }\n      } catch (error) {\n        console.error(\"WebSocket 메시지 파싱 오류:\", error);\n      }\n    };\n    if (wsConnected) {\n      addMessageListener(handleWebSocketMessage);\n    }\n    return () => {\n      if (wsConnected) {\n        removeMessageListener(handleWebSocketMessage);\n      }\n    };\n  }, [wsConnected, addMessageListener, removeMessageListener, scrollToBottom]);\n\n  /**\n   * 스트리밍 응답 처리 함수\n   */\n  const handleStreamingResponse = useCallback((chunk, metadata) => {\n    const currentStreamingId = streamingMessageIdRef.current;\n    console.log(\"청크 수신:\", chunk, \"스트리밍 ID:\", currentStreamingId);\n    if (!currentStreamingId) {\n      console.error(\"스트리밍 ID가 없습니다!\");\n      return;\n    }\n    setMessages(prev => {\n      const updatedMessages = [...prev];\n      const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n      if (streamingMsgIndex !== -1) {\n        // 기존 스트리밍 메시지 업데이트\n        updatedMessages[streamingMsgIndex] = {\n          ...updatedMessages[streamingMsgIndex],\n          content: updatedMessages[streamingMsgIndex].content + chunk,\n          isLoading: true,\n          isStreaming: true\n        };\n        console.log(\"스트리밍 메시지 업데이트 성공:\", updatedMessages[streamingMsgIndex].content);\n      } else {\n        console.error(\"스트리밍 메시지를 찾을 수 없음:\", currentStreamingId);\n      }\n      return updatedMessages;\n    });\n\n    // 스크롤 조정 (사용자가 스크롤 중이 아닐 때만)\n    if (!isUserScrolling) {\n      scrollToBottom();\n    }\n  }, [scrollToBottom, isUserScrolling]);\n\n  /**\n   * 스트리밍 완료 처리 함수\n   */\n  const handleStreamingComplete = useCallback(result => {\n    const currentStreamingId = streamingMessageIdRef.current;\n    console.log(\"스트리밍 완료:\", result, \"스트리밍 ID:\", currentStreamingId);\n    if (!currentStreamingId) {\n      console.error(\"스트리밍 완료 처리 중 ID가 없습니다!\");\n      return;\n    }\n    setMessages(prev => {\n      const updatedMessages = [...prev];\n      const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n      if (streamingMsgIndex !== -1) {\n        // 스트리밍 메시지 완료 처리\n        updatedMessages[streamingMsgIndex] = {\n          ...updatedMessages[streamingMsgIndex],\n          content: result.result,\n          isLoading: false,\n          isStreaming: false,\n          performance_metrics: result.performance_metrics,\n          model_info: result.model_info,\n          timestamp: new Date().toISOString()\n        };\n        console.log(\"스트리밍 완료 처리 성공:\", updatedMessages[streamingMsgIndex].content);\n      } else {\n        console.error(\"스트리밍 완료 처리 중 메시지를 찾을 수 없음:\", currentStreamingId);\n      }\n      return updatedMessages;\n    });\n\n    // 스트리밍 ID 초기화\n    streamingMessageIdRef.current = null;\n\n    // 입력 활성화\n    console.log(\"WebSocket 스트리밍 완료 - 입력 활성화\");\n    setCanSendMessage(true);\n\n    // 스크롤 조정 (스트리밍 완료 시에는 항상 하단으로)\n    scrollToBottom();\n  }, [scrollToBottom]);\n\n  /**\n   * 스트리밍 중단 함수\n   */\n  const handleStopGeneration = useCallback(() => {\n    console.log(\"생성 중단 요청\");\n\n    // WebSocket 연결 종료\n    if (currentWebSocketRef.current) {\n      currentWebSocketRef.current.close();\n      currentWebSocketRef.current = null;\n    }\n\n    // 현재 실행 중인 작업 중단\n    if (currentExecutionIdRef.current) {\n      // 여기서 실제 API 호출 중단 로직을 추가할 수 있습니다\n      currentExecutionIdRef.current = null;\n    }\n\n    // 스트리밍 메시지 상태 업데이트\n    const currentStreamingId = streamingMessageIdRef.current;\n    if (currentStreamingId) {\n      setMessages(prev => {\n        const updatedMessages = [...prev];\n        const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === currentStreamingId);\n        if (streamingMsgIndex !== -1) {\n          updatedMessages[streamingMsgIndex] = {\n            ...updatedMessages[streamingMsgIndex],\n            content: updatedMessages[streamingMsgIndex].content + \"\\n\\n[생성이 중단되었습니다]\",\n            isLoading: false,\n            isStreaming: false,\n            timestamp: new Date().toISOString()\n          };\n        }\n        return updatedMessages;\n      });\n      streamingMessageIdRef.current = null;\n    }\n\n    // 입력 가능 상태로 복원\n    setCanSendMessage(true);\n\n    // orchestration 상태 리셋\n    resetOrchestration();\n    toast.success(\"생성이 중단되었습니다\");\n  }, [resetOrchestration]);\n\n  /**\n   * 입력창 높이 자동 조절\n   */\n  const adjustInputHeight = useCallback(value => {\n    if (!value.trim()) {\n      setInputHeight(24); // 기본 높이\n      return;\n    }\n\n    // 줄 수 계산 (대략적)\n    const lines = value.split(\"\\n\").length;\n    const charBasedLines = Math.ceil(value.length / 80); // 80자당 1줄로 추정\n    const estimatedLines = Math.max(lines, charBasedLines);\n\n    // 높이 계산 (lineHeight: 1.4, fontSize: 16px)\n    let calculatedHeight;\n    if (estimatedLines <= 3) {\n      calculatedHeight = 24 + (estimatedLines - 1) * 22; // 기본 + 추가 줄\n    } else if (estimatedLines <= 10) {\n      calculatedHeight = 150 + (estimatedLines - 6) * 15; // 중간 범위\n    } else {\n      calculatedHeight = Math.min(400, 150 + (estimatedLines - 6) * 12); // 최대 400px\n    }\n    setInputHeight(Math.max(24, calculatedHeight));\n  }, []);\n\n  /**\n   * 입력값 변경 처리\n   */\n  const handleInputChange = useCallback(value => {\n    setInputValue(value);\n    adjustInputHeight(value);\n  }, [adjustInputHeight]);\n\n  /**\n   * 메시지 전송\n   */\n  const handleSendMessage = useCallback(async () => {\n    console.log(\"해들 전송 호출:\", {\n      inputValue: inputValue.trim(),\n      isGenerating,\n      canSendMessage\n    });\n    if (!inputValue.trim() || isGenerating) {\n      console.log(\"전송 중단: 조건 부족\");\n      return;\n    }\n\n    // 입력 비활성화\n    console.log(\"입력 비활성화\");\n    setCanSendMessage(false);\n    const userMessage = {\n      id: \"user-\" + Date.now(),\n      type: \"user\",\n      content: inputValue.trim(),\n      timestamp: new Date().toISOString()\n    };\n\n    // 스트리밍 메시지 ID 생성\n    const streamMsgId = \"streaming-\" + Date.now();\n    streamingMessageIdRef.current = streamMsgId;\n    console.log(\"새 스트리밍 메시지 ID 생성:\", streamMsgId);\n\n    // 스트리밍 응답을 위한 초기 메시지\n    const streamingMessage = {\n      id: streamMsgId,\n      type: \"assistant\",\n      content: \"\",\n      timestamp: new Date().toISOString(),\n      isLoading: true,\n      isStreaming: true\n    };\n    setMessages(prev => [...prev, userMessage, streamingMessage]);\n    setInputValue(\"\");\n    setInputHeight(24); // 입력창 높이 초기화\n\n    // 기존 메시지 + 현재 사용자 메시지를 포함한 대화 히스토리 생성\n    const allMessages = [...messages, userMessage];\n    const chatHistory = allMessages.filter(msg => !msg.isLoading && !msg.isError && !msg.isStreaming).map(msg => ({\n      role: msg.type === \"user\" ? \"user\" : \"assistant\",\n      content: msg.content\n    }));\n\n    // 최대 대화 기억 설정 (최근 50개 메시지로 최대 메모리 유지)\n    const maxHistoryLength = 50;\n    const trimmedChatHistory = chatHistory.slice(-maxHistoryLength);\n    console.log(\"대화 히스토리 생성:\", {\n      totalMessages: allMessages.length,\n      fullHistoryLength: chatHistory.length,\n      trimmedHistoryLength: trimmedChatHistory.length,\n      maxHistoryLength: maxHistoryLength,\n      recentHistory: trimmedChatHistory.slice(-6) // 최근 6개만 로그에 표시\n    });\n    try {\n      // 프롬프트 카드 정보 추가 - 활성화된 카드만 필터링하고 백엔드 형식에 맞게 변환\n      const safePromptCards = Array.isArray(promptCards) ? promptCards : [];\n      const activePromptCards = safePromptCards.filter(card => card.isActive !== false && card.enabled !== false).map(card => ({\n        promptId: card.promptId || card.prompt_id,\n        title: card.title || \"Untitled\",\n        prompt_text: card.prompt_text || card.content || \"\",\n        tags: card.tags || [],\n        isActive: card.isActive !== false,\n        stepOrder: card.stepOrder || 0\n      })).filter(card => card.prompt_text.trim()) // 프롬프트 내용이 있는 것만\n      .sort((a, b) => (a.stepOrder || 0) - (b.stepOrder || 0)); // stepOrder로 정렬\n\n      console.log(\"대화 전송 데이터 확인:\", {\n        messageContent: userMessage.content,\n        chatHistoryLength: trimmedChatHistory.length,\n        promptCardsCount: activePromptCards.length,\n        chatHistory: trimmedChatHistory,\n        promptCards: activePromptCards.map(card => ({\n          id: card.promptId,\n          title: card.title,\n          contentLength: card.prompt_text.length,\n          stepOrder: card.stepOrder,\n          hasContent: !!card.prompt_text.trim()\n        }))\n      });\n\n      // WebSocket 연결 확인 및 실시간 스트리밍 시도\n      if (wsConnected) {\n        console.log(\"WebSocket을 통한 실시간 스트리밍 시작\");\n        console.log(\"🔍 [DEBUG] 스트리밍 매개변수 상세 확인:\", {\n          projectId,\n          userInput: userMessage.content,\n          conversationId: conversationId,\n          userSub: user === null || user === void 0 ? void 0 : user.id,\n          historyLength: trimmedChatHistory.length,\n          promptCardsLength: activePromptCards.length,\n          conversationIdType: typeof conversationId,\n          conversationIdValue: conversationId,\n          isConversationIdNull: conversationId === null,\n          isConversationIdUndefined: conversationId === undefined\n        });\n        const success = wsStartStreaming(userMessage.content, trimmedChatHistory, activePromptCards, selectedModel, conversationId, // Add conversationId\n        user === null || user === void 0 ? void 0 : user.id // Add userSub from AuthContext\n        );\n        if (success) {\n          // WebSocket 스트리밍 성공, 나머지는 리스너에서 처리\n          return;\n        } else {\n          console.log(\"WebSocket 전송 실패, SSE 폴백 모드로 전환\");\n        }\n      } else {\n        console.log(\"WebSocket 미연결, SSE 모드 사용\");\n      }\n\n      // 🌟 멀티-에이전트 시스템 실행\n      console.log(\"멀티-에이전트 시스템 실행 시작\");\n\n      // 1. 먼저 프롬프트 카드들을 crew 인스턴스로 생성\n      if (activePromptCards.length > 0) {\n        try {\n          console.log(\"프롬프트 카드 → 크루 인스턴스 변환 시도\");\n          await crewAPI.createCrewInstance(projectId, activePromptCards);\n          console.log(\"크루 인스턴스 생성 완료\");\n        } catch (instanceError) {\n          var _instanceError$respon;\n          console.log(\"크루 인스턴스 생성 실패:\", instanceError.message);\n\n          // 401 인증 오류인 경우 처리 중단\n          if (((_instanceError$respon = instanceError.response) === null || _instanceError$respon === void 0 ? void 0 : _instanceError$respon.status) === 401) {\n            const {\n              shouldRedirect\n            } = await handleAPIError(instanceError);\n            if (shouldRedirect) {\n              return;\n            }\n          }\n\n          // 다른 오류는 로그만 남기고 계속 진행 (이미 존재하는 경우 등)\n          console.log(\"크루 인스턴스 관련 오류이지만 계속 진행합니다\");\n        }\n      }\n\n      // 2. 멀티-에이전트 병렬 실행\n      const multiAgentResult = await crewAPI.executeMultiAgent(projectId, userMessage.content, progress => {\n        // 진행상황 업데이트 (옵션)\n        console.log(\"멀티-에이전트 진행상황:\", progress);\n      });\n      console.log(\"멀티-에이전트 실행 완료:\", multiAgentResult);\n\n      // 3. 결과를 UI 메시지로 변환\n      const assistantMessage = processMultiAgentResponse(multiAgentResult);\n\n      // 4. 스트리밍 메시지를 최종 결과로 교체\n      setMessages(prev => {\n        const updatedMessages = [...prev];\n        const streamingMsgIndex = updatedMessages.findIndex(msg => msg.id === streamingMessageIdRef.current);\n        if (streamingMsgIndex !== -1) {\n          updatedMessages[streamingMsgIndex] = assistantMessage;\n        } else {\n          updatedMessages.push(assistantMessage);\n        }\n        return updatedMessages;\n      });\n      streamingMessageIdRef.current = null;\n      setCanSendMessage(true);\n\n      // 성공 토스트\n      toast.success(`${Object.keys(multiAgentResult.agentResults || {}).length}개 에이전트 분석 완료!`);\n    } catch (error) {\n      var _error$response;\n      console.error(\"메시지 전송 실패:\", error);\n\n      // API 오류 처리 위임\n      const {\n        userMessage: errorUserMessage,\n        shouldRedirect\n      } = await handleAPIError(error);\n\n      // 인증 오류로 리다이렉트가 필요한 경우\n      if (shouldRedirect) {\n        return;\n      }\n      const errorMessage = {\n        id: \"error-\" + Date.now(),\n        type: \"assistant\",\n        content: errorUserMessage,\n        timestamp: new Date().toISOString(),\n        isError: true,\n        errorDetails: {\n          message: error.message,\n          status: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status,\n          code: error.code\n        }\n      };\n      setMessages(prev => {\n        // 스트리밍 메시지를 찾아 제거\n        const currentStreamingId = streamingMessageIdRef.current;\n        const filteredMessages = prev.filter(msg => msg.id !== currentStreamingId);\n        return [...filteredMessages, errorMessage];\n      });\n      streamingMessageIdRef.current = null;\n\n      // 오류 발생 시도 입력 활성화\n      setCanSendMessage(true);\n    }\n\n    // 전체 전송 과정 완료 후 입력 활성화 (보험용)\n    setCanSendMessage(true);\n  }, [inputValue, isGenerating, executeOrchestration, handleStreamingResponse, handleStreamingComplete, messages]);\n\n  /**\n   * Enter 키로 전송\n   */\n  const handleKeyPress = useCallback(e => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSendMessage();\n    }\n  }, [handleSendMessage]);\n\n  /**\n   * 메시지 복사\n   */\n  const handleCopyMessage = useCallback(async (content, messageId) => {\n    const success = await copyToClipboard(content);\n    if (success) {\n      setCopiedMessage(messageId);\n      setTimeout(() => setCopiedMessage(null), 2000);\n    }\n  }, []);\n\n  /**\n   * 개별 제목 복사\n   */\n  const handleCopyTitle = useCallback(async (title, messageId, index) => {\n    const success = await copyToClipboard(title, \"복사되었습니다!\");\n    if (success) {\n      setCopiedMessage(`${messageId}_title_${index}`);\n      setTimeout(() => setCopiedMessage(null), 2000);\n    }\n  }, []);\n\n  /**\n   * 채팅 초기화\n   */\n  const resetChat = useCallback(() => {\n    console.log(\"🔍 [DEBUG] useChat 완전 초기화 실행\");\n    setMessages([]);\n    setInputValue(\"\");\n    setCopiedMessage(null);\n    setCanSendMessage(true);\n    setInputHeight(24);\n    setIsUserScrolling(false);\n    streamingMessageIdRef.current = null;\n    currentWebSocketRef.current = null;\n    currentExecutionIdRef.current = null;\n    resetOrchestration();\n  }, [resetOrchestration]);\n\n  // conversationId가 null로 변경될 때 자동으로 초기화\n  useEffect(() => {\n    if (conversationId === null) {\n      console.log(\"🔍 [DEBUG] conversationId가 null로 변경됨 - 채팅 완전 초기화\");\n      resetChat();\n    }\n  }, [conversationId, resetChat]);\n  return {\n    messages,\n    inputValue,\n    setInputValue,\n    handleInputChange,\n    // 새로운 입력 핸들러\n    copiedMessage,\n    isGenerating,\n    isStreaming,\n    canSendMessage,\n    streamingMessageId: streamingMessageIdRef.current,\n    messagesEndRef,\n    inputRef,\n    inputHeight,\n    // 동적 높이\n    handleSendMessage,\n    handleStopGeneration,\n    handleKeyPress,\n    handleCopyMessage,\n    handleCopyTitle,\n    resetChat,\n    scrollToBottom,\n    // WebSocket 상태 추가\n    wsConnected,\n    wsConnecting,\n    wsError,\n    // 스크롤 관련 추가\n    scrollContainerRef,\n    handleScroll,\n    isUserScrolling,\n    // 모델 선택 관련 추가\n    selectedModel,\n    setSelectedModel\n  };\n};\n_s(useChat, \"ecN+upbJ7jWDEaoGxEye20uAFdg=\", false, function () {\n  return [useAuth, useOrchestration, useWebSocket];\n});","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","toast","copyToClipboard","useOrchestration","useWebSocket","crewAPI","handleAPIError","useAuth","processMultiAgentResponse","result","console","error","id","Date","now","type","content","timestamp","toISOString","isError","agentResults","finalTitles","tokenUsage","agentSummary","Object","keys","map","agentType","agentResult","titles","agentName","getAgentName","tokenCount","allTitles","values","flat","formatMultiAgentContent","isMultiAgent","agentNames","journalism","balanced","click","seo","social","length","forEach","title","index","agent","useChat","projectId","projectName","promptCards","conversationId","createConversationFn","setCurrentConversationFn","_s","user","isFirstRender","current","log","promptCardsLength","conversationIdType","isConversationIdNull","isConversationIdUndefined","undefined","userId","newConversationId","isNull","isUndefined","messages","setMessages","inputValue","setInputValue","copiedMessage","setCopiedMessage","canSendMessage","setCanSendMessage","inputHeight","setInputHeight","selectedModel","setSelectedModel","streamingMessageIdRef","currentWebSocketRef","currentExecutionIdRef","messagesEndRef","inputRef","isUserScrolling","setIsUserScrolling","scrollContainerRef","lastScrollTopRef","isExecuting","isGenerating","isStreaming","executeOrchestration","resetOrchestration","isConnected","wsConnected","isConnecting","wsConnecting","wsError","startStreaming","wsStartStreaming","addMessageListener","removeMessageListener","previousMessages","handleScroll","container","currentScrollTop","scrollTop","maxScrollTop","scrollHeight","clientHeight","Math","abs","isAtBottom","scrollToBottom","scrollIntoView","behavior","handleWebSocketMessage","event","_data$message7","data","JSON","parse","currentStreamingId","step","progress","prev","updatedMessages","streamingMsgIndex","findIndex","msg","messagesLength","currentContent","isLoading","m","fullContent","message","_data$message","_data$message2","_data$message3","_data$message4","_data$message5","_data$message6","errorContent","includes","toastMessage","handleStreamingResponse","chunk","metadata","handleStreamingComplete","performance_metrics","model_info","handleStopGeneration","close","success","adjustInputHeight","value","trim","lines","split","charBasedLines","ceil","estimatedLines","max","calculatedHeight","min","handleInputChange","handleSendMessage","userMessage","streamMsgId","streamingMessage","allMessages","chatHistory","filter","role","maxHistoryLength","trimmedChatHistory","slice","totalMessages","fullHistoryLength","trimmedHistoryLength","recentHistory","safePromptCards","Array","isArray","activePromptCards","card","isActive","enabled","promptId","prompt_id","prompt_text","tags","stepOrder","sort","a","b","messageContent","chatHistoryLength","promptCardsCount","contentLength","hasContent","userInput","userSub","historyLength","conversationIdValue","createCrewInstance","instanceError","_instanceError$respon","response","status","shouldRedirect","multiAgentResult","executeMultiAgent","assistantMessage","push","_error$response","errorUserMessage","errorMessage","errorDetails","code","filteredMessages","handleKeyPress","e","key","shiftKey","preventDefault","handleCopyMessage","messageId","setTimeout","handleCopyTitle","resetChat","streamingMessageId"],"sources":["/Users/yeong-gwang/Documents/work/서울경제신문/dev/nexus/title_generator_ver1/frontend/src/hooks/useChat.js"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from \"react\";\nimport { toast } from \"react-hot-toast\";\nimport { copyToClipboard } from \"../utils/clipboard\";\nimport { useOrchestration } from \"./useOrchestration\";\nimport { useWebSocket } from \"./useWebSocket\";\nimport { crewAPI, handleAPIError } from \"../services/api\";\nimport { useAuth } from \"../contexts/AuthContext\";\n\n/**\n * 멀티-에이전트 AI 응답을 파싱하고 UI에 맞는 메시지 객체로 변환\n */\nconst processMultiAgentResponse = (result) => {\n  if (!result) {\n    console.error(\"멀티-에이전트 응답 오류: 결과가 없습니다\", result);\n    return {\n      id: \"error-\" + Date.now(),\n      type: \"assistant\",\n      content: \"처리 중 오류가 발생했습니다. 다시 시도해주세요.\",\n      timestamp: new Date().toISOString(),\n      isError: true,\n    };\n  }\n\n  // 멀티-에이전트 결과 구성\n  const agentResults = result.agentResults || {};\n  const finalTitles = result.finalTitles || {};\n  const tokenUsage = result.tokenUsage || 0;\n\n  // 에이전트별 결과를 포맷팅\n  const agentSummary = Object.keys(agentResults).map((agentType) => {\n    const agentResult = agentResults[agentType];\n    const titles = finalTitles[agentType] || [];\n\n    return {\n      agentType,\n      agentName: getAgentName(agentType),\n      result: agentResult?.content || \"결과 없음\",\n      titles: titles,\n      tokenCount: agentResult?.tokenCount || 0,\n    };\n  });\n\n  // 전체 제목 목록 생성\n  const allTitles = Object.values(finalTitles).flat();\n\n  return {\n    id: \"multi-agent-\" + Date.now(),\n    type: \"assistant\",\n    content: formatMultiAgentContent(agentSummary, allTitles),\n    timestamp: new Date(),\n    // 멀티-에이전트 특화 데이터\n    isMultiAgent: true,\n    agentResults: agentSummary,\n    allTitles: allTitles,\n    tokenUsage: tokenUsage,\n  };\n};\n\n/**\n * 에이전트 타입을 한국어 이름으로 변환\n */\nconst getAgentName = (agentType) => {\n  const agentNames = {\n    journalism: \"📰 저널리즘 충실형\",\n    balanced: \"⚖️ 균형잡힌 후킹형\",\n    click: \"🎯 클릭유도형\",\n    seo: \"🔍 SEO/AEO 최적화형\",\n    social: \"📱 소셜미디어 공유형\",\n  };\n  return agentNames[agentType] || `🤖 ${agentType}`;\n};\n\n/**\n * 멀티-에이전트 결과를 UI 표시용 텍스트로 포맷팅\n */\nconst formatMultiAgentContent = (agentSummary, allTitles) => {\n  let content = \"🚀 **멀티-에이전트 분석 완료**\\n\\n\";\n\n  // 전체 제목 요약\n  if (allTitles.length > 0) {\n    content += \"📋 **생성된 제목 목록:**\\n\";\n    allTitles.forEach((title, index) => {\n      content += `${index + 1}. ${title}\\n`;\n    });\n    content += \"\\n\";\n  }\n\n  // 에이전트별 상세 결과\n  content += \"🔍 **에이전트별 분석 결과:**\\n\\n\";\n  agentSummary.forEach((agent) => {\n    content += `### ${agent.agentName}\\n`;\n    if (agent.titles.length > 0) {\n      content += \"**생성 제목:**\\n\";\n      agent.titles.forEach((title) => {\n        content += `• ${title}\\n`;\n      });\n    }\n    content += `**토큰 사용량:** ${agent.tokenCount}개\\n\\n`;\n  });\n\n  return content;\n};\n\n/**\n * 채팅 기능을 위한 커스텀 훅\n * @param {string} projectId - 프로젝트 ID\n * @param {string} projectName - 프로젝트 이름\n * @param {Array} promptCards - 프롬프트 카드 배열\n * @returns {Object} - 채팅 관련 상태와 함수들\n */\nexport const useChat = (\n  projectId,\n  projectName,\n  promptCards = [],\n  conversationId = null,\n  createConversationFn = null,\n  setCurrentConversationFn = null\n) => {\n  const { user } = useAuth(); // Add user from AuthContext\n\n  // 디버깅 로그 (첫 번째 렌더링에만)\n  const isFirstRender = useRef(true);\n  if (isFirstRender.current) {\n    console.log(\"🔍 [DEBUG] useChat 초기화:\", {\n      projectId,\n      projectName,\n      promptCardsLength: promptCards?.length,\n      conversationId,\n      conversationIdType: typeof conversationId,\n      isConversationIdNull: conversationId === null,\n      isConversationIdUndefined: conversationId === undefined,\n      userId: user?.id,\n    });\n    isFirstRender.current = false;\n  }\n  \n  // conversationId 변경 감지\n  useEffect(() => {\n    console.log(\"🔍 [DEBUG] useChat - conversationId 변경:\", {\n      newConversationId: conversationId,\n      conversationIdType: typeof conversationId,\n      isNull: conversationId === null,\n      isUndefined: conversationId === undefined,\n    });\n  }, [conversationId]);\n  const [messages, setMessages] = useState([]);\n  const [inputValue, setInputValue] = useState(\"\");\n  const [copiedMessage, setCopiedMessage] = useState(null);\n  const [canSendMessage, setCanSendMessage] = useState(true);\n  const [inputHeight, setInputHeight] = useState(24); // 동적 높이 관리\n  const [selectedModel, setSelectedModel] = useState(\n    \"anthropic.claude-3-5-sonnet-20241022-v2:0\"\n  );\n  const streamingMessageIdRef = useRef(null);\n  const currentWebSocketRef = useRef(null);\n  const currentExecutionIdRef = useRef(null);\n\n  const messagesEndRef = useRef(null);\n  const inputRef = useRef(null);\n\n  // 사용자 스크롤 상태 추적\n  const [isUserScrolling, setIsUserScrolling] = useState(false);\n  const scrollContainerRef = useRef(null);\n  const lastScrollTopRef = useRef(0);\n\n  const {\n    isExecuting: isGenerating,\n    isStreaming,\n    executeOrchestration,\n    resetOrchestration,\n  } = useOrchestration(projectId);\n\n  // WebSocket 훅 추가\n  const {\n    isConnected: wsConnected,\n    isConnecting: wsConnecting,\n    error: wsError,\n    startStreaming: wsStartStreaming,\n    addMessageListener,\n    removeMessageListener,\n  } = useWebSocket(projectId);\n\n  // 초기 메시지 설정 - projectId 또는 conversationId 변경시 초기화\n  useEffect(() => {\n    console.log(\"🔍 [DEBUG] useChat 메시지 초기화:\", {\n      projectId,\n      conversationId,\n      previousMessages: messages.length\n    });\n    setMessages([]); // 빈 배열로 시작\n  }, [projectId, conversationId]); // conversationId 추가\n\n  // 사용자 스크롤 감지 함수\n  const handleScroll = useCallback(() => {\n    if (!scrollContainerRef.current) return;\n\n    const container = scrollContainerRef.current;\n    const currentScrollTop = container.scrollTop;\n    const maxScrollTop = container.scrollHeight - container.clientHeight;\n\n    // 사용자가 수동으로 스크롤했는지 감지\n    if (Math.abs(currentScrollTop - lastScrollTopRef.current) > 2) {\n      const isAtBottom = currentScrollTop >= maxScrollTop - 20;\n\n      // 하단에 있을 때만 자동 스크롤 허용, 그 외는 사용자 스크롤 모드\n      setIsUserScrolling(!isAtBottom);\n    }\n\n    lastScrollTopRef.current = currentScrollTop;\n  }, []);\n\n  const scrollToBottom = useCallback(() => {\n    // 사용자가 스크롤 중이 아닐 때만 자동 스크롤\n    if (!isUserScrolling && messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({ behavior: \"smooth\" });\n    }\n  }, [isUserScrolling]);\n\n  // 메시지 추가 시 스크롤 하단으로 (사용자 스크롤 중이 아닐 때만)\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages, scrollToBottom]);\n\n  // WebSocket 메시지 리스너 설정\n  useEffect(() => {\n    const handleWebSocketMessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log(\"WebSocket 메시지 수신:\", data);\n\n        const currentStreamingId = streamingMessageIdRef.current;\n\n        switch (data.type) {\n          case \"stream_start\":\n            console.log(\"WebSocket 스트리밍 시작\");\n            break;\n\n          case \"progress\":\n            // 진행 상황 로그만 남기고 UI 업데이트는 제거\n            console.log(`진행 상황: ${data.step} (${data.progress}%)`);\n            break;\n\n          case \"stream_chunk\":\n            if (currentStreamingId) {\n              setMessages((prev) => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(\n                  (msg) => msg.id === currentStreamingId\n                );\n\n                console.log(\"스트림 청크 처리:\", {\n                  currentStreamingId,\n                  streamingMsgIndex,\n                  messagesLength: prev.length,\n                  content: data.content,\n                });\n\n                if (streamingMsgIndex !== -1) {\n                  // 기존 내용에 새 청크 추가\n                  const currentContent =\n                    updatedMessages[streamingMsgIndex].content || \"\";\n\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: currentContent + data.content,\n                    isLoading: true,\n                    isStreaming: true,\n                  };\n\n                  console.log(\n                    \"메시지 업데이트됨:\",\n                    updatedMessages[streamingMsgIndex]\n                  );\n                } else {\n                  console.log(\n                    \"스트리밍 메시지를 찾을 수 없음, 메시지 ID들:\",\n                    prev.map((m) => m.id)\n                  );\n                }\n\n                return updatedMessages;\n              });\n              // 스트리밍 중에는 사용자가 스크롤 중이 아닐 때만 자동 스크롤\n              if (!isUserScrolling) {\n                scrollToBottom();\n              }\n            } else {\n              console.log(\"currentStreamingId가 null임\");\n            }\n            break;\n\n          case \"stream_complete\":\n            if (currentStreamingId) {\n              setMessages((prev) => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(\n                  (msg) => msg.id === currentStreamingId\n                );\n\n                if (streamingMsgIndex !== -1) {\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: data.fullContent,\n                    isLoading: false,\n                    isStreaming: false,\n                    timestamp: new Date().toISOString(),\n                  };\n                }\n\n                return updatedMessages;\n              });\n              streamingMessageIdRef.current = null;\n              scrollToBottom();\n            }\n            break;\n\n          case \"error\":\n            console.error(\"WebSocket 스트리밍 오류:\", data.message);\n            if (currentStreamingId) {\n              setMessages((prev) => {\n                const updatedMessages = [...prev];\n                const streamingMsgIndex = updatedMessages.findIndex(\n                  (msg) => msg.id === currentStreamingId\n                );\n\n                if (streamingMsgIndex !== -1) {\n                  // 오류 유형에 따른 사용자 메시지 결정\n                  let errorContent =\n                    \"메시지 처리 중 오류가 발생했습니다. 다시 시도해주세요.\";\n\n                  if (\n                    data.message?.includes(\"401\") ||\n                    data.message?.includes(\"Unauthorized\")\n                  ) {\n                    errorContent =\n                      \"인증이 만료되었습니다. 다시 로그인해주세요.\";\n                  } else if (\n                    data.message?.includes(\"timeout\") ||\n                    data.message?.includes(\"시간 초과\")\n                  ) {\n                    errorContent =\n                      \"처리 시간이 초과되었습니다. 요청을 단순화하거나 잠시 후 다시 시도해주세요.\";\n                  } else if (\n                    data.message?.includes(\"rate limit\") ||\n                    data.message?.includes(\"제한\")\n                  ) {\n                    errorContent =\n                      \"요청 한도에 도달했습니다. 잠시 후 다시 시도해주세요.\";\n                  }\n\n                  updatedMessages[streamingMsgIndex] = {\n                    ...updatedMessages[streamingMsgIndex],\n                    content: errorContent,\n                    isLoading: false,\n                    isStreaming: false,\n                    isError: true,\n                    timestamp: new Date().toISOString(),\n                  };\n                }\n\n                return updatedMessages;\n              });\n              streamingMessageIdRef.current = null;\n            }\n\n            // 사용자 친화적인 토스트 메시지\n            const toastMessage = data.message?.includes(\"401\")\n              ? \"인증이 만료되었습니다\"\n              : \"처리 중 오류가 발생했습니다\";\n            toast.error(toastMessage);\n            break;\n\n          default:\n            console.log(\"알 수 없는 WebSocket 메시지 타입:\", data.type);\n        }\n      } catch (error) {\n        console.error(\"WebSocket 메시지 파싱 오류:\", error);\n      }\n    };\n\n    if (wsConnected) {\n      addMessageListener(handleWebSocketMessage);\n    }\n\n    return () => {\n      if (wsConnected) {\n        removeMessageListener(handleWebSocketMessage);\n      }\n    };\n  }, [wsConnected, addMessageListener, removeMessageListener, scrollToBottom]);\n\n  /**\n   * 스트리밍 응답 처리 함수\n   */\n  const handleStreamingResponse = useCallback(\n    (chunk, metadata) => {\n      const currentStreamingId = streamingMessageIdRef.current;\n\n      console.log(\"청크 수신:\", chunk, \"스트리밍 ID:\", currentStreamingId);\n\n      if (!currentStreamingId) {\n        console.error(\"스트리밍 ID가 없습니다!\");\n        return;\n      }\n\n      setMessages((prev) => {\n        const updatedMessages = [...prev];\n        const streamingMsgIndex = updatedMessages.findIndex(\n          (msg) => msg.id === currentStreamingId\n        );\n\n        if (streamingMsgIndex !== -1) {\n          // 기존 스트리밍 메시지 업데이트\n          updatedMessages[streamingMsgIndex] = {\n            ...updatedMessages[streamingMsgIndex],\n            content: updatedMessages[streamingMsgIndex].content + chunk,\n            isLoading: true,\n            isStreaming: true,\n          };\n          console.log(\n            \"스트리밍 메시지 업데이트 성공:\",\n            updatedMessages[streamingMsgIndex].content\n          );\n        } else {\n          console.error(\"스트리밍 메시지를 찾을 수 없음:\", currentStreamingId);\n        }\n\n        return updatedMessages;\n      });\n\n      // 스크롤 조정 (사용자가 스크롤 중이 아닐 때만)\n      if (!isUserScrolling) {\n        scrollToBottom();\n      }\n    },\n    [scrollToBottom, isUserScrolling]\n  );\n\n  /**\n   * 스트리밍 완료 처리 함수\n   */\n  const handleStreamingComplete = useCallback(\n    (result) => {\n      const currentStreamingId = streamingMessageIdRef.current;\n\n      console.log(\"스트리밍 완료:\", result, \"스트리밍 ID:\", currentStreamingId);\n\n      if (!currentStreamingId) {\n        console.error(\"스트리밍 완료 처리 중 ID가 없습니다!\");\n        return;\n      }\n\n      setMessages((prev) => {\n        const updatedMessages = [...prev];\n        const streamingMsgIndex = updatedMessages.findIndex(\n          (msg) => msg.id === currentStreamingId\n        );\n\n        if (streamingMsgIndex !== -1) {\n          // 스트리밍 메시지 완료 처리\n          updatedMessages[streamingMsgIndex] = {\n            ...updatedMessages[streamingMsgIndex],\n            content: result.result,\n            isLoading: false,\n            isStreaming: false,\n            performance_metrics: result.performance_metrics,\n            model_info: result.model_info,\n            timestamp: new Date().toISOString(),\n          };\n          console.log(\n            \"스트리밍 완료 처리 성공:\",\n            updatedMessages[streamingMsgIndex].content\n          );\n        } else {\n          console.error(\n            \"스트리밍 완료 처리 중 메시지를 찾을 수 없음:\",\n            currentStreamingId\n          );\n        }\n\n        return updatedMessages;\n      });\n\n      // 스트리밍 ID 초기화\n      streamingMessageIdRef.current = null;\n\n      // 입력 활성화\n      console.log(\"WebSocket 스트리밍 완료 - 입력 활성화\");\n      setCanSendMessage(true);\n\n      // 스크롤 조정 (스트리밍 완료 시에는 항상 하단으로)\n      scrollToBottom();\n    },\n    [scrollToBottom]\n  );\n\n  /**\n   * 스트리밍 중단 함수\n   */\n  const handleStopGeneration = useCallback(() => {\n    console.log(\"생성 중단 요청\");\n\n    // WebSocket 연결 종료\n    if (currentWebSocketRef.current) {\n      currentWebSocketRef.current.close();\n      currentWebSocketRef.current = null;\n    }\n\n    // 현재 실행 중인 작업 중단\n    if (currentExecutionIdRef.current) {\n      // 여기서 실제 API 호출 중단 로직을 추가할 수 있습니다\n      currentExecutionIdRef.current = null;\n    }\n\n    // 스트리밍 메시지 상태 업데이트\n    const currentStreamingId = streamingMessageIdRef.current;\n    if (currentStreamingId) {\n      setMessages((prev) => {\n        const updatedMessages = [...prev];\n        const streamingMsgIndex = updatedMessages.findIndex(\n          (msg) => msg.id === currentStreamingId\n        );\n\n        if (streamingMsgIndex !== -1) {\n          updatedMessages[streamingMsgIndex] = {\n            ...updatedMessages[streamingMsgIndex],\n            content:\n              updatedMessages[streamingMsgIndex].content +\n              \"\\n\\n[생성이 중단되었습니다]\",\n            isLoading: false,\n            isStreaming: false,\n            timestamp: new Date().toISOString(),\n          };\n        }\n\n        return updatedMessages;\n      });\n\n      streamingMessageIdRef.current = null;\n    }\n\n    // 입력 가능 상태로 복원\n    setCanSendMessage(true);\n\n    // orchestration 상태 리셋\n    resetOrchestration();\n\n    toast.success(\"생성이 중단되었습니다\");\n  }, [resetOrchestration]);\n\n  /**\n   * 입력창 높이 자동 조절\n   */\n  const adjustInputHeight = useCallback((value) => {\n    if (!value.trim()) {\n      setInputHeight(24); // 기본 높이\n      return;\n    }\n\n    // 줄 수 계산 (대략적)\n    const lines = value.split(\"\\n\").length;\n    const charBasedLines = Math.ceil(value.length / 80); // 80자당 1줄로 추정\n    const estimatedLines = Math.max(lines, charBasedLines);\n\n    // 높이 계산 (lineHeight: 1.4, fontSize: 16px)\n    let calculatedHeight;\n    if (estimatedLines <= 3) {\n      calculatedHeight = 24 + (estimatedLines - 1) * 22; // 기본 + 추가 줄\n    } else if (estimatedLines <= 10) {\n      calculatedHeight = 150 + (estimatedLines - 6) * 15; // 중간 범위\n    } else {\n      calculatedHeight = Math.min(400, 150 + (estimatedLines - 6) * 12); // 최대 400px\n    }\n\n    setInputHeight(Math.max(24, calculatedHeight));\n  }, []);\n\n  /**\n   * 입력값 변경 처리\n   */\n  const handleInputChange = useCallback(\n    (value) => {\n      setInputValue(value);\n      adjustInputHeight(value);\n    },\n    [adjustInputHeight]\n  );\n\n  /**\n   * 메시지 전송\n   */\n  const handleSendMessage = useCallback(async () => {\n    console.log(\"해들 전송 호출:\", {\n      inputValue: inputValue.trim(),\n      isGenerating,\n      canSendMessage,\n    });\n\n    if (!inputValue.trim() || isGenerating) {\n      console.log(\"전송 중단: 조건 부족\");\n      return;\n    }\n\n    // 입력 비활성화\n    console.log(\"입력 비활성화\");\n    setCanSendMessage(false);\n\n    const userMessage = {\n      id: \"user-\" + Date.now(),\n      type: \"user\",\n      content: inputValue.trim(),\n      timestamp: new Date().toISOString(),\n    };\n\n    // 스트리밍 메시지 ID 생성\n    const streamMsgId = \"streaming-\" + Date.now();\n    streamingMessageIdRef.current = streamMsgId;\n\n    console.log(\"새 스트리밍 메시지 ID 생성:\", streamMsgId);\n\n    // 스트리밍 응답을 위한 초기 메시지\n    const streamingMessage = {\n      id: streamMsgId,\n      type: \"assistant\",\n      content: \"\",\n      timestamp: new Date().toISOString(),\n      isLoading: true,\n      isStreaming: true,\n    };\n\n    setMessages((prev) => [...prev, userMessage, streamingMessage]);\n    setInputValue(\"\");\n    setInputHeight(24); // 입력창 높이 초기화\n\n    // 기존 메시지 + 현재 사용자 메시지를 포함한 대화 히스토리 생성\n    const allMessages = [...messages, userMessage];\n    const chatHistory = allMessages\n      .filter((msg) => !msg.isLoading && !msg.isError && !msg.isStreaming)\n      .map((msg) => ({\n        role: msg.type === \"user\" ? \"user\" : \"assistant\",\n        content: msg.content,\n      }));\n\n    // 최대 대화 기억 설정 (최근 50개 메시지로 최대 메모리 유지)\n    const maxHistoryLength = 50;\n    const trimmedChatHistory = chatHistory.slice(-maxHistoryLength);\n\n    console.log(\"대화 히스토리 생성:\", {\n      totalMessages: allMessages.length,\n      fullHistoryLength: chatHistory.length,\n      trimmedHistoryLength: trimmedChatHistory.length,\n      maxHistoryLength: maxHistoryLength,\n      recentHistory: trimmedChatHistory.slice(-6), // 최근 6개만 로그에 표시\n    });\n\n    try {\n      // 프롬프트 카드 정보 추가 - 활성화된 카드만 필터링하고 백엔드 형식에 맞게 변환\n      const safePromptCards = Array.isArray(promptCards) ? promptCards : [];\n      const activePromptCards = safePromptCards\n        .filter((card) => card.isActive !== false && card.enabled !== false)\n        .map((card) => ({\n          promptId: card.promptId || card.prompt_id,\n          title: card.title || \"Untitled\",\n          prompt_text: card.prompt_text || card.content || \"\",\n          tags: card.tags || [],\n          isActive: card.isActive !== false,\n          stepOrder: card.stepOrder || 0,\n        }))\n        .filter((card) => card.prompt_text.trim()) // 프롬프트 내용이 있는 것만\n        .sort((a, b) => (a.stepOrder || 0) - (b.stepOrder || 0)); // stepOrder로 정렬\n\n      console.log(\"대화 전송 데이터 확인:\", {\n        messageContent: userMessage.content,\n        chatHistoryLength: trimmedChatHistory.length,\n        promptCardsCount: activePromptCards.length,\n        chatHistory: trimmedChatHistory,\n        promptCards: activePromptCards.map((card) => ({\n          id: card.promptId,\n          title: card.title,\n          contentLength: card.prompt_text.length,\n          stepOrder: card.stepOrder,\n          hasContent: !!card.prompt_text.trim(),\n        })),\n      });\n\n      // WebSocket 연결 확인 및 실시간 스트리밍 시도\n      if (wsConnected) {\n        console.log(\"WebSocket을 통한 실시간 스트리밍 시작\");\n        console.log(\"🔍 [DEBUG] 스트리밍 매개변수 상세 확인:\", {\n          projectId,\n          userInput: userMessage.content,\n          conversationId: conversationId,\n          userSub: user?.id,\n          historyLength: trimmedChatHistory.length,\n          promptCardsLength: activePromptCards.length,\n          conversationIdType: typeof conversationId,\n          conversationIdValue: conversationId,\n          isConversationIdNull: conversationId === null,\n          isConversationIdUndefined: conversationId === undefined,\n        });\n\n        const success = wsStartStreaming(\n          userMessage.content,\n          trimmedChatHistory,\n          activePromptCards,\n          selectedModel,\n          conversationId, // Add conversationId\n          user?.id // Add userSub from AuthContext\n        );\n\n        if (success) {\n          // WebSocket 스트리밍 성공, 나머지는 리스너에서 처리\n          return;\n        } else {\n          console.log(\"WebSocket 전송 실패, SSE 폴백 모드로 전환\");\n        }\n      } else {\n        console.log(\"WebSocket 미연결, SSE 모드 사용\");\n      }\n\n      // 🌟 멀티-에이전트 시스템 실행\n      console.log(\"멀티-에이전트 시스템 실행 시작\");\n\n      // 1. 먼저 프롬프트 카드들을 crew 인스턴스로 생성\n      if (activePromptCards.length > 0) {\n        try {\n          console.log(\"프롬프트 카드 → 크루 인스턴스 변환 시도\");\n          await crewAPI.createCrewInstance(projectId, activePromptCards);\n          console.log(\"크루 인스턴스 생성 완료\");\n        } catch (instanceError) {\n          console.log(\"크루 인스턴스 생성 실패:\", instanceError.message);\n\n          // 401 인증 오류인 경우 처리 중단\n          if (instanceError.response?.status === 401) {\n            const { shouldRedirect } = await handleAPIError(instanceError);\n            if (shouldRedirect) {\n              return;\n            }\n          }\n\n          // 다른 오류는 로그만 남기고 계속 진행 (이미 존재하는 경우 등)\n          console.log(\"크루 인스턴스 관련 오류이지만 계속 진행합니다\");\n        }\n      }\n\n      // 2. 멀티-에이전트 병렬 실행\n      const multiAgentResult = await crewAPI.executeMultiAgent(\n        projectId,\n        userMessage.content,\n        (progress) => {\n          // 진행상황 업데이트 (옵션)\n          console.log(\"멀티-에이전트 진행상황:\", progress);\n        }\n      );\n\n      console.log(\"멀티-에이전트 실행 완료:\", multiAgentResult);\n\n      // 3. 결과를 UI 메시지로 변환\n      const assistantMessage = processMultiAgentResponse(multiAgentResult);\n\n      // 4. 스트리밍 메시지를 최종 결과로 교체\n      setMessages((prev) => {\n        const updatedMessages = [...prev];\n        const streamingMsgIndex = updatedMessages.findIndex(\n          (msg) => msg.id === streamingMessageIdRef.current\n        );\n\n        if (streamingMsgIndex !== -1) {\n          updatedMessages[streamingMsgIndex] = assistantMessage;\n        } else {\n          updatedMessages.push(assistantMessage);\n        }\n\n        return updatedMessages;\n      });\n\n      streamingMessageIdRef.current = null;\n      setCanSendMessage(true);\n\n      // 성공 토스트\n      toast.success(\n        `${\n          Object.keys(multiAgentResult.agentResults || {}).length\n        }개 에이전트 분석 완료!`\n      );\n    } catch (error) {\n      console.error(\"메시지 전송 실패:\", error);\n\n      // API 오류 처리 위임\n      const { userMessage: errorUserMessage, shouldRedirect } =\n        await handleAPIError(error);\n\n      // 인증 오류로 리다이렉트가 필요한 경우\n      if (shouldRedirect) {\n        return;\n      }\n\n      const errorMessage = {\n        id: \"error-\" + Date.now(),\n        type: \"assistant\",\n        content: errorUserMessage,\n        timestamp: new Date().toISOString(),\n        isError: true,\n        errorDetails: {\n          message: error.message,\n          status: error.response?.status,\n          code: error.code,\n        },\n      };\n\n      setMessages((prev) => {\n        // 스트리밍 메시지를 찾아 제거\n        const currentStreamingId = streamingMessageIdRef.current;\n        const filteredMessages = prev.filter(\n          (msg) => msg.id !== currentStreamingId\n        );\n        return [...filteredMessages, errorMessage];\n      });\n\n      streamingMessageIdRef.current = null;\n\n      // 오류 발생 시도 입력 활성화\n      setCanSendMessage(true);\n    }\n\n    // 전체 전송 과정 완료 후 입력 활성화 (보험용)\n    setCanSendMessage(true);\n  }, [\n    inputValue,\n    isGenerating,\n    executeOrchestration,\n    handleStreamingResponse,\n    handleStreamingComplete,\n    messages,\n  ]);\n\n  /**\n   * Enter 키로 전송\n   */\n  const handleKeyPress = useCallback(\n    (e) => {\n      if (e.key === \"Enter\" && !e.shiftKey) {\n        e.preventDefault();\n        handleSendMessage();\n      }\n    },\n    [handleSendMessage]\n  );\n\n  /**\n   * 메시지 복사\n   */\n  const handleCopyMessage = useCallback(async (content, messageId) => {\n    const success = await copyToClipboard(content);\n    if (success) {\n      setCopiedMessage(messageId);\n      setTimeout(() => setCopiedMessage(null), 2000);\n    }\n  }, []);\n\n  /**\n   * 개별 제목 복사\n   */\n  const handleCopyTitle = useCallback(async (title, messageId, index) => {\n    const success = await copyToClipboard(title, \"복사되었습니다!\");\n    if (success) {\n      setCopiedMessage(`${messageId}_title_${index}`);\n      setTimeout(() => setCopiedMessage(null), 2000);\n    }\n  }, []);\n\n  /**\n   * 채팅 초기화\n   */\n  const resetChat = useCallback(() => {\n    console.log(\"🔍 [DEBUG] useChat 완전 초기화 실행\");\n    setMessages([]);\n    setInputValue(\"\");\n    setCopiedMessage(null);\n    setCanSendMessage(true);\n    setInputHeight(24);\n    setIsUserScrolling(false);\n    streamingMessageIdRef.current = null;\n    currentWebSocketRef.current = null;\n    currentExecutionIdRef.current = null;\n    resetOrchestration();\n  }, [resetOrchestration]);\n\n  // conversationId가 null로 변경될 때 자동으로 초기화\n  useEffect(() => {\n    if (conversationId === null) {\n      console.log(\"🔍 [DEBUG] conversationId가 null로 변경됨 - 채팅 완전 초기화\");\n      resetChat();\n    }\n  }, [conversationId, resetChat]);\n\n  return {\n    messages,\n    inputValue,\n    setInputValue,\n    handleInputChange, // 새로운 입력 핸들러\n    copiedMessage,\n    isGenerating,\n    isStreaming,\n    canSendMessage,\n    streamingMessageId: streamingMessageIdRef.current,\n    messagesEndRef,\n    inputRef,\n    inputHeight, // 동적 높이\n    handleSendMessage,\n    handleStopGeneration,\n    handleKeyPress,\n    handleCopyMessage,\n    handleCopyTitle,\n    resetChat,\n    scrollToBottom,\n    // WebSocket 상태 추가\n    wsConnected,\n    wsConnecting,\n    wsError,\n    // 스크롤 관련 추가\n    scrollContainerRef,\n    handleScroll,\n    isUserScrolling,\n    // 모델 선택 관련 추가\n    selectedModel,\n    setSelectedModel,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}